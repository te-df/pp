<!--
 * 7_JS_Modules
 * Módulos JavaScript e lógica de negócio
 * 
 * Consolidado em: 2025-10-21 01:14:28
 * Total de arquivos: 20
 * Total de linhas: 7900
 -->

/**
 * 7_JS_Modules
 * Módulos JavaScript e lógica de negócio
 * 
 * Consolidado em: 2025-10-21 01:14:28
 * Total de arquivos: 20
 * Total de linhas: 7900
 */

<!--============================================================================-->
<!-- ARQUIVO: JS-ArchivingIntegration.html -->
<!--============================================================================-->

<script>
/**
 * ============================================================================
 * ARCHIVING INTEGRATION - JAVASCRIPT
 * ============================================================================
 * Funções JavaScript para integrar sistema de arquivamento com frontend
 * Inclua este arquivo em suas páginas principais
 * 
 * Versão: 1.0
 * Data: 2025-10-20
 * ============================================================================
 */

/**
 * Namespace global para funções de arquivamento
 */
window.ArchivingAPI = {
  
  /**
   * Obtém status atual do sistema
   */
  getStatus: function(callback) {
    google.script.run
      .withSuccessHandler(callback)
      .withFailureHandler(error => {
        console.error('Erro ao obter status:', error);
        callback({ success: false, error: error.message });
      })
      .getArchivingStatus();
  },
  
  /**
   * Obtém apenas tamanho do dataset (leve)
   */
  getDatasetSize: function(callback) {
    google.script.run
      .withSuccessHandler(callback)
      .withFailureHandler(error => {
        console.error('Erro ao obter tamanho:', error);
        callback({ success: false, error: error.message });
      })
      .getDatasetSize();
  },
  
  /**
   * Lista arquivos históricos
   */
  listArchives: function(callback) {
    google.script.run
      .withSuccessHandler(callback)
      .withFailureHandler(error => {
        console.error('Erro ao listar arquivos:', error);
        callback({ success: false, error: error.message });
      })
      .listArchivedFiles();
  },
  
  /**
   * Obtém status dos triggers
   */
  getTriggers: function(callback) {
    google.script.run
      .withSuccessHandler(callback)
      .withFailureHandler(error => {
        console.error('Erro ao obter triggers:', error);
        callback({ success: false, error: error.message });
      })
      .getTriggerStatus();
  },
  
  /**
   * Executa limpeza manual
   */
  cleanupNow: function(callback) {
    if (!confirm('Executar limpeza manual agora?\n\nIsso irá arquivar e limpar dados conforme política de retenção.')) {
      return;
    }
    
    google.script.run
      .withSuccessHandler(callback)
      .withFailureHandler(error => {
        console.error('Erro ao executar limpeza:', error);
        callback({ success: false, error: error.message });
      })
      .executeManualCleanup();
  },
  
  /**
   * Executa apenas arquivamento (sem limpar)
   */
  archiveNow: function(callback) {
    if (!confirm('Executar arquivamento manual agora?\n\nIsso irá criar um backup dos dados temporários.')) {
      return;
    }
    
    google.script.run
      .withSuccessHandler(callback)
      .withFailureHandler(error => {
        console.error('Erro ao executar arquivamento:', error);
        callback({ success: false, error: error.message });
      })
      .executeManualArchive();
  },
  
  /**
   * Obtém políticas de retenção
   */
  getRetentionPolicies: function(callback) {
    google.script.run
      .withSuccessHandler(callback)
      .withFailureHandler(error => {
        console.error('Erro ao obter políticas:', error);
        callback({ success: false, error: error.message });
      })
      .getRetentionPolicies();
  },
  
  /**
   * Configura triggers automáticos
   */
  setupTriggers: function(callback) {
    if (!confirm('Configurar triggers automáticos?\n\nIsso irá ativar:\n- Limpeza diária (2h)\n- Relatório semanal (domingo 23h)\n- Backup mensal (dia 1 às 1h)')) {
      return;
    }
    
    google.script.run
      .withSuccessHandler(callback)
      .withFailureHandler(error => {
        console.error('Erro ao configurar triggers:', error);
        callback({ success: false, error: error.message });
      })
      .setupTriggersViaAPI();
  },
  
  /**
   * Remove todos os triggers
   */
  removeTriggers: function(callback) {
    if (!confirm('Remover TODOS os triggers automáticos?\n\nIsso irá desativar todas as automações.')) {
      return;
    }
    
    google.script.run
      .withSuccessHandler(callback)
      .withFailureHandler(error => {
        console.error('Erro ao remover triggers:', error);
        callback({ success: false, error: error.message });
      })
      .removeAllTriggersViaAPI();
  },
  
  /**
   * Obtém estatísticas do Drive
   */
  getDriveStats: function(callback) {
    google.script.run
      .withSuccessHandler(callback)
      .withFailureHandler(error => {
        console.error('Erro ao obter stats do Drive:', error);
        callback({ success: false, error: error.message });
      })
      .getDriveUsageStats();
  }
};

/**
 * Funções auxiliares de formatação
 */
window.ArchivingUtils = {
  
  /**
   * Formata número com separadores
   */
  formatNumber: function(num) {
    return new Intl.NumberFormat('pt-BR').format(num);
  },
  
  /**
   * Formata data
   */
  formatDate: function(dateStr) {
    if (!dateStr) return 'N/A';
    const date = new Date(dateStr);
    return date.toLocaleString('pt-BR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  },
  
  /**
   * Formata bytes para MB
   */
  formatBytes: function(bytes) {
    return (bytes / (1024 * 1024)).toFixed(2);
  },
  
  /**
   * Calcula porcentagem
   */
  calculatePercent: function(value, max) {
    return Math.min((value / max) * 100, 100).toFixed(1);
  },
  
  /**
   * Mostra toast de notificação
   */
  showToast: function(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.innerHTML = `
      <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
      <span>${message}</span>
    `;
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.animation = 'slideOut 0.3s ease';
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  },
  
  /**
   * Mostra loading overlay
   */
  showLoading: function(message = 'Carregando...') {
    const overlay = document.createElement('div');
    overlay.id = 'loadingOverlay';
    overlay.className = 'loading-overlay';
    overlay.innerHTML = `
      <div class="loading-content">
        <div class="spinner"></div>
        <div>${message}</div>
      </div>
    `;
    
    document.body.appendChild(overlay);
  },
  
  /**
   * Esconde loading overlay
   */
  hideLoading: function() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) overlay.remove();
  }
};

/**
 * Widget de status compacto para header/dashboard
 */
window.ArchivingWidget = {
  
  /**
   * Cria widget de status compacto
   */
  create: function(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = `
      <div  class="flex items-center" style="gap: 16px; padding: 12px 16px; background: rgba(255,255,255,0.1); border-radius: 8px">
        <div  class="flex items-center" style="gap: 8px">
          <i class="fas fa-database"  style="color: white"></i>
          <span  class="font-semibold" style="color: white; font-size: 14px">Dataset:</span>
          <span id="widgetSize"  style="color: white; font-weight: 700">---</span>
        </div>
        <div  class="flex items-center" style="gap: 8px">
          <i class="fas fa-chart-line"  style="color: white"></i>
          <span id="widgetRecords"  style="color: white; font-weight: 700">---</span>
        </div>
        <div id="widgetStatus"  style="width: 12px; height: 12px; border-radius: 50%; background: #10b981"></div>
      </div>
    `;
    
    // Atualiza dados
    this.update();
    
    // Auto-refresh a cada 60 segundos
    setInterval(() => this.update(), 60000);
  },
  
  /**
   * Atualiza widget
   */
  update: function() {
    ArchivingAPI.getDatasetSize(response => {
      if (!response.success) return;
      
      const data = response.data;
      const sizeEl = document.getElementById('widgetSize');
      const recordsEl = document.getElementById('widgetRecords');
      const statusEl = document.getElementById('widgetStatus');
      
      if (sizeEl) sizeEl.textContent = data.totalSizeMB + ' MB';
      if (recordsEl) recordsEl.textContent = ArchivingUtils.formatNumber(data.totalRecords);
      
      // Atualiza cor do status
      if (statusEl) {
        const sizeMB = parseFloat(data.totalSizeMB);
        if (sizeMB > 50) {
          statusEl.style.background = '#ef4444'; // Crítico
        } else if (sizeMB > 20) {
          statusEl.style.background = '#f59e0b'; // Atenção
        } else {
          statusEl.style.background = '#10b981'; // OK
        }
      }
    });
  }
};

console.log('✅ Archiving Integration carregado');
</script>

<style>
@keyframes slideOut {
  to {
    transform: translateX(400px);
    opacity: 0;
  }
}
</style>

<!--============================================================================-->
<!-- ARQUIVO: JS-AuthManager.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 AUTH MANAGER - Gerenciamento de Autenticação e Sessão
 Controla login, logout, permissões e sessão do usuário
 ============================================================================ */
(function() {
    'use strict';

 const AuthManager = {
 currentUser: null,
        sessionKey: 'sigte_session',

 // Usuários de demo (substitua por chamada ao backend em produção)
 demoUsers: {
            'monitor01': {
                username: 'monitor01',
                password: 'monitor123', // Em produção, use hash
                role: 'MONITOR',
                nome: 'Silva Monitor',
                permissions: ['frequencia:read', 'frequencia:write', 'rotas:read']
 },
            'secretario01': {
                username: 'secretario01',
                password: 'secret123',
                role: 'SECRETARIO',
                nome: 'Ana Secretária',
                permissions: ['eventos:read', 'eventos:write', 'reposicao:write', 'relatorios:read']
 },
            'admin': {
                username: 'admin',
                password: 'Admin@2026', // <-- ALTERE AQUI PARA UMA SENHA FORTE
                role: 'ADMIN',
                nome: 'Administrador',
                permissions: ['*'] // Todas as permissões
 }
 },

 init() {
            console.log('[AuthManager] Inicializando...');
 this.loadSession();
 this.setupEventListeners();
 this.updateUI();
 },

 /**
 * Realiza login do usuário
 */
 async login(username, password) {
 try {
                Logger.info('[Auth] Tentativa de login:', username);

 // Em produção, chamar API
                // const response = await API.run('authenticateUser', { username, password });

 // Demo: validação local
 const user = this.demoUsers[username];

 if (!user) {
                    throw new Error('Usuário não encontrado');
 }

 if (user.password !== password) {
                    throw new Error('Senha incorreta');
 }

 // Criar sessão
 this.currentUser = {
 username: user.username,
 nome: user.nome,
 role: user.role,
 permissions: user.permissions,
 loginTime: new Date().toISOString()
 };

 // Salvar sessão
 this.saveSession();

                Logger.info('[Auth] Login bem-sucedido:', this.currentUser.nome);
                ToastManager.show(`Bem-vindo(a), ${this.currentUser.nome}!`, 'success');

 // Atualizar UI
 this.updateUI();

 // Redirecionar para dashboard apropriado
 this.redirectToDashboard();

 return { success: true, user: this.currentUser };

 } catch (error) {
                Logger.error('[Auth] Erro no login:', error);
                ToastManager.show(error.message || 'Erro ao fazer login', 'error');
 return { success: false, error: error.message };
 }
 },

 /**
 * Realiza logout do usuário
 */
 logout() {
            Logger.info('[Auth] Fazendo logout:', this.currentUser?.username);

 this.currentUser = null;
 this.clearSession();
 this.updateUI();

            ToastManager.show('Você saiu do sistema', 'info');

 // Redirecionar para login
 this.showLoginScreen();
 },

 /**
 * Verifica se usuário está logado
 */
 isLoggedIn() {
 return this.currentUser !== null;
 },

 /**
 * Verifica se usuário tem permissão
 */
 hasPermission(permission) {
 if (!this.currentUser) return false;

 // Admin tem todas as permissões
            if (this.currentUser.permissions.includes('*')) return true;

 return this.currentUser.permissions.includes(permission);
 },

 /**
 * Obtém usuário atual
 */
 getCurrentUser() {
 return this.currentUser;
 },

 /**
 * Salva sessão no localStorage
 */
 saveSession() {
 if (this.currentUser) {
 localStorage.setItem(this.sessionKey, JSON.stringify(this.currentUser));
 }
 },

 /**
 * Carrega sessão do localStorage
 */
 loadSession() {
 try {
 const sessionData = localStorage.getItem(this.sessionKey);
 if (sessionData) {
 this.currentUser = JSON.parse(sessionData);
                    Logger.info('[Auth] Sessão restaurada:', this.currentUser.username);
 }
 } catch (error) {
                Logger.error('[Auth] Erro ao carregar sessão:', error);
 this.clearSession();
 }
 },

 /**
 * Limpa sessão
 */
 clearSession() {
 localStorage.removeItem(this.sessionKey);
 },

 /**
 * Atualiza UI com base no estado de autenticação
 */
 updateUI() {
            const authBtn = document.getElementById('auth-btn');
            const userName = document.getElementById('user-name-display');

 if (this.isLoggedIn()) {
 // Usuário logado - BOTÃO VIRA LOGOUT
 if (authBtn) {
                    authBtn.innerHTML = '<i class="fas fa-sign-out-alt"></i>';
 authBtn.title = `Sair (${this.currentUser.nome})`;
                    authBtn.classList.add('logged-in');
                    authBtn.style.color = 'var(--error, var(--md-sys-color-error))'; // Vermelho para logout
 }
 if (userName) {
 userName.textContent = this.currentUser.nome;
 }

 // Mostrar/ocultar seções baseado em permissões
 this.applyPermissions();

 // Disparar evento para outros componentes
                document.dispatchEvent(new CustomEvent('auth-changed', {
 detail: { loggedIn: true, user: this.currentUser }
 }));

 } else {
 // Usuário não logado - BOTÃO VIRA LOGIN
 if (authBtn) {
                    authBtn.innerHTML = '<i class="fas fa-sign-in-alt"></i>';
                    authBtn.title = 'Fazer Login';
                    authBtn.classList.remove('logged-in');
                    authBtn.style.color = ''; // Voltar cor padrão
 }
 if (userName) {
                    userName.textContent = 'Visitante';
 }

 // Disparar evento para outros componentes
                document.dispatchEvent(new CustomEvent('auth-changed', {
 detail: { loggedIn: false }
 }));
 }
 },

 /**
 * Aplica permissões na UI
 */
 applyPermissions() {
 // Esconder seções sem permissão
            const navButtons = document.querySelectorAll('.nav-btn');
 navButtons.forEach(btn => {
 const section = btn.dataset.section;
 const permission = `${section}:read`;

                if (!this.hasPermission(permission) && !this.hasPermission('*')) {
                    btn.style.display = 'none';
 } else {
                    btn.style.display = '';
 }
 });
 },

 /**
 * Redireciona para dashboard apropriado
 */
 redirectToDashboard() {
 if (!this.currentUser) return;

 const dashboards = {
                'MONITOR': 'frequencia-section',
                'SECRETARIO': 'eventos-section',
                'ADMIN': 'dashboard-section'
 };

            const targetSection = dashboards[this.currentUser.role] || 'dashboard-section';

 // Navegar para seção apropriada
            if (typeof NavigationManager !== 'undefined') {
 NavigationManager.navigateToSection(targetSection);
 }
 },

 /**
 * Mostra tela de login
 */
 showLoginScreen() {
            if (typeof DrawerManager !== 'undefined') {
                DrawerManager.openDrawer('user-drawer');
 }
 },

 /**
 * Configura event listeners
 */
 setupEventListeners() {
 // Listener para formulário de login
            document.addEventListener('submit', (e) => {
                if (e.target.id === 'login-form') {
 e.preventDefault();
 this.handleLoginSubmit(e.target);
 }
 });

 // Listener para logout
            document.addEventListener('click', (e) => {
                if (e.target.closest('#logout-btn, .logout-btn')) {
 e.preventDefault();
 this.logout();
 }

 // NOVO: Comportamento alternado do botão auth-btn
                if (e.target.closest('#auth-btn')) {
                    const btn = e.target.closest('#auth-btn');

 if (this.isLoggedIn()) {
 // Se logado, fazer logout direto
 e.preventDefault();
 e.stopPropagation();

 // Confirmar logout
 if (confirm(`Deseja sair da conta de ${this.currentUser.nome}?`)) {
 this.logout();

 // Fechar drawer se estiver aberto
                            if (typeof closeDrawer !== 'undefined') {
                                closeDrawer('user-drawer');
 }
 }
 }
 // Se não logado, deixar o DrawerManager abrir o drawer normalmente
 }
 });
 },

 /**
 * Processa submissão do formulário de login
 */
 async handleLoginSubmit(form) {
            const username = form.querySelector('#login-username')?.value;
            const password = form.querySelector('#login-password')?.value;

 if (!username || !password) {
                ToastManager.show('Preencha usuário e senha', 'warning');
 return;
 }

            LoadingManager.show('Autenticando...');

 const result = await this.login(username, password);

 LoadingManager.hide();

 if (result.success) {
 // Fechar drawer de login
                if (typeof DrawerManager !== 'undefined') {
                    DrawerManager.closeDrawer('user-drawer');
 }

 // Limpar formulário
 form.reset();
 }
 }
 };

 // Expor globalmente
 window.AuthManager = AuthManager;

 // Inicializar quando DOM estiver pronto
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => AuthManager.init());
 } else {
 AuthManager.init();
 }

    console.log('[AuthManager] Script carregado');

})();
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-BusinessLogic.html -->
<!--============================================================================-->

<script>
/** ============================================================================
 BUSINESS LOGIC - Attendance, CRUD, Section-specific logic
 ============================================================================
 Versão: 2.0 (Refatorado por Gemini Code Assist)
 - Refatorado para usar um despachante de eventos data-driven.
 - Integração com SheetMappingManager para reduzir duplicação.
 ============================================================================ */

(function() {
    'use strict';

    document.addEventListener('DOMContentLoaded', () => {
 // ============================================================================
 // ATTENDANCE MANAGER (Frequência)
 // ============================================================================

 const AttendanceManager = {
 studentsData: [],
 currentRouteId: null,

 init() {
                const frequenciaSection = document.getElementById('frequencia-section');
 if (!frequenciaSection) return;
                this.vehicleSelect = document.getElementById('veiculo_id');

 // Listeners para os botões de ação da seção de frequência (usando delegação de eventos)
                frequenciaSection.addEventListener('click', (e) => {
                    if (e.target.id === 'submit-frequency-btn') this.saveAttendance();
                    if (e.target.closest('#mark-all-present')) this.markAllAs('Presente');
                    if (e.target.closest('#mark-all-absent')) this.markAllAs('Ausente');
 });

 // Listener para o seletor de rotas
                const routeSelect = document.getElementById('frequencia-rota');
 if (routeSelect) {
                    routeSelect.addEventListener('change', (e) => this.loadVehiclesForRoute(e.target.value));
                    routeSelect.addEventListener('change', (e) => this.loadStudentsForRoute(e.target.value));
 }

 // Carrega dados quando a seção se torna visível
                document.addEventListener('sectionChanged', (e) => { // Este evento é disparado pelo JS-Navigation.html
                    if (e.detail.section === 'frequencia') {
 this.loadInitialData(); // Carrega as rotas no seletor
 }
 });
 },

 async loadInitialData() {
                const routeSelect = document.getElementById('frequencia-rota');
 if (!routeSelect || routeSelect.options.length > 1) return; // Já carregado

                if (!window.API) { ToastManager.show('API não inicializada.', 'error'); return; }
                LoadingManager.show('Carregando rotas...');
 try {
                    const routes = await API.run('readRecords', { sheetName: 'Rotas' });
                    routeSelect.innerHTML = '<option value="">Selecione a rota...</option>'; // Limpa e adiciona placeholder
 (routes || []).forEach(route => routeSelect.add(new Option(`${route.Codigo} - ${route.Nome_Rota}`, route.ID, false, false)));
 } catch (error) {
                    console.error('[Attendance] Erro ao carregar rotas:', error);
                    ToastManager.show('Falha ao carregar rotas.', 'error');
 } finally {
 LoadingManager.hide();
 }
 },

 async loadVehiclesForRoute(routeId) {
 if (!this.vehicleSelect) return;
                this.vehicleSelect.innerHTML = '<option value="">Carregando veículos...</option>';
 this.vehicleSelect.disabled = true;

 if (!routeId) {
                    this.vehicleSelect.innerHTML = '<option value="">Selecione uma rota primeiro</option>';
 return;
 }

                LoadingManager.show('Carregando veículos...');
 try {
                    const routeData = await API.run('readRecords', { sheetName: 'Rotas', filters: { ID: routeId } });
                    if (!routeData || routeData.length === 0) throw new Error('Rota não encontrada.');

                    const empresa = routeData[0].Empresa; // Assumindo que a rota tem um campo 'Empresa'
                    const vehicles = await API.run('readRecords', {
                        sheetName: 'Veiculos',
                        filters: { Empresa: empresa, Status: 'Operacional' }
 });

                    this.vehicleSelect.innerHTML = '<option value="">Selecione um veículo...</option>';
 (vehicles || []).forEach(vehicle => this.vehicleSelect.add(new Option(`${vehicle.Placa} - ${vehicle.Modelo}`, vehicle.ID)));
 this.vehicleSelect.disabled = false;
 } catch (error) {
                    console.error('[Attendance] Erro ao carregar veículos:', error);
                    this.vehicleSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                    ToastManager.show('Falha ao carregar veículos da rota.', 'error');
 } finally {
 LoadingManager.hide();
 }
 },

 async loadStudentsForRoute(routeId) {
                const studentsListContainer = document.getElementById('students-attendance-list');
 if (!routeId) {
 this.studentsData = [];
 this.renderStudentList();
 studentsListContainer.innerHTML = `
                        <div class="student-attendance-placeholder">
                            <i class="fas fa-users"></i>
 <p>Selecione uma rota para carregar a lista de alunos.</p>
 </div>`;
 return;
 }
 this.currentRouteId = routeId;
 LoadingManager.show(`Carregando alunos da rota...`);
 try {
 // A chamada à API agora filtra os alunos pela rota e status
                    this.studentsData = await API.run('readRecords', {
                        sheetName: 'Alunos',
                        filters: { 'Rota_ID': routeId, 'Status_Ativo': 'Ativo' }
 });
 this.renderStudentList();

 // Validação de capacidade após carregar alunos
 const vehicleId = this.vehicleSelect.value;
 if (vehicleId) BusinessRulesManager.validateAndDisplayCapacity(vehicleId, this.studentsData);

                    ToastManager.show(`${this.studentsData.length} alunos carregados.`, 'success');
 } catch (error) {
 console.error(`[Attendance] Erro ao carregar alunos da rota ${routeId}:`, error);
                    ToastManager.show('Falha ao carregar alunos da rota.', 'error');
 studentsListContainer.innerHTML = `
                        <div class="student-attendance-placeholder">
                            <i class="fas fa-exclamation-triangle"></i>
 <p>Erro ao carregar alunos. Tente novamente.</p>
 </div>`;
 } finally {
 LoadingManager.hide();
 }
 },

 renderStudentList() {
                const container = document.getElementById('students-attendance-list');
 if (!container) return;

 if (this.studentsData.length === 0) {
 container.innerHTML = `
                        <div class="student-attendance-placeholder">
                            <i class="fas fa-user-slash"></i>
 <p>Nenhum aluno ativo encontrado para esta rota.</p>
 </div>`;
 return;
 }

 container.innerHTML = this.studentsData.map(student => `
                    <div class="student-attendance-item">
                        <div class="student-info">
                            <div class="student-avatar">${student.Nome_Completo.charAt(0)}</div>
                            <div class="student-details">
                                <div class="student-name">${student.Nome_Completo}</div>
                                <div class="student-school">${student.Escola}</div>
 </div>
 </div>
                        <div class="attendance-controls">
                            <label class="attendance-radio present">
                                <input type="radio" name="status-${student.ID}" value="Presente" checked onchange="AttendanceManager.updateCount()">
 <span>P</span>
 </label>
                            <label class="attendance-radio absent">
                                <input type="radio" name="status-${student.ID}" value="Ausente" onchange="AttendanceManager.updateCount()">
 <span>A</span>
 </label>
 </div>
 </div>
                `).join('');
 },

 markAllAs(status) {
                const radios = document.querySelectorAll(`.attendance-radio input[value="${status}"]`);
 radios.forEach(radio => radio.checked = true);
 this.updateCount(); // Corrigido
                ToastManager.show(`Todos os alunos marcados como '${status}'`, 'success', 800);
 },

 updateCount() {
                const presentCount = document.querySelectorAll('input[value="Presente"]:checked').length;
                const absentCount = document.querySelectorAll('input[value="Ausente"]:checked').length;
                const presentEl = document.getElementById('present-count');
                const absentEl = document.getElementById('absent-count');
 if(presentEl) presentEl.textContent = presentCount;
 if(absentEl) absentEl.textContent = absentCount;
 },

 async saveAttendance() {
                const form = document.getElementById('daily-attendance-form');
 if (!form.checkValidity()) {
                    ToastManager.show('⚠ Preencha todos os campos obrigatórios da viagem', 'warning');
 form.reportValidity();
 return;
 }

 const attendanceRecords = [];
 this.studentsData.forEach(student => {
                    const statusInput = document.querySelector(`input[name="status-${student.ID}"]:checked`);
 if (statusInput) {
 attendanceRecords.push({
 Aluno_ID: student.ID,
 Nome_Aluno: student.Nome_Completo,
 Status_Presenca: statusInput.value
 });
 }
 });

 if (attendanceRecords.length === 0) {
                    ToastManager.show('⚠ Marque a presença de pelo menos um aluno', 'warning');
 return;
 }

 const formData = new FormData(form);
 const tripData = Object.fromEntries(formData.entries());
 tripData.attendance = attendanceRecords;

 // Obtém botão de submit para loading state
                const submitButton = document.getElementById('submit-frequency-btn');

 try {
 if (submitButton) LoadingManager.showButtonLoading(submitButton);
                    LoadingManager.show('Salvando frequência...');

                    const result = await API.run('saveAttendance', tripData);
                    ToastManager.show(`✓ ${result.message || 'Frequência salva com sucesso!'}`, 'success');
 form.reset();
 this.studentsData = [];
 this.renderStudentList();
 } catch (error) {
                    console.error('[Attendance] Erro ao salvar:', error);
                    ToastManager.show(`✗ Erro: ${error.message}`, 'error');
 } finally {
 if (submitButton) LoadingManager.hideButtonLoading(submitButton);
 LoadingManager.hide();
 }
 }
 };

 // Expose globally
 window.AttendanceManager = AttendanceManager;
 AttendanceManager.init();

 // ============================================================================
 // DASHBOARD MANAGER
 // ============================================================================
 const DashboardManager = {
    charts: {},
    isInitialized: false,

    init(container) {
        if (this.isInitialized) return;
        console.log('[DashboardManager] Inicializando Dashboard.');
        this.render(container);
        setTimeout(() => this.renderCharts(), 100);
        this.isInitialized = true;
    },

    destroyCharts() {
        Object.values(this.charts).forEach(chart => {
            if (chart && typeof chart.destroy === 'function') {
                chart.destroy();
            }
        });
        this.charts = {};
    },

    renderCharts() {
        this.destroyCharts();

        // --- Gráfico de Frequência Semanal (Linha) ---
        const attendanceCtx = document.getElementById('attendance-chart')?.getContext('2d');
        if (attendanceCtx) {
            this.charts.attendanceChart = new Chart(attendanceCtx, {
                type: 'line',
                data: {
                    labels: ['Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'],
                    datasets: [{
                        label: 'Presentes',
                        data: [1200, 1220, 1210, 1230, 1180, 850],
                        borderColor: 'var(--md-sys-color-primary)',
                        backgroundColor: 'rgba(100, 181, 246, 0.2)',
                        tension: 0.4,
                        fill: true,
                    }, {
                        label: 'Ausentes',
                        data: [50, 45, 55, 40, 60, 30],
                        borderColor: 'var(--md-sys-color-error)',
                        backgroundColor: 'rgba(239, 83, 80, 0.2)',
                        tension: 0.4,
                        fill: true,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: 'var(--color-text-secondary)' },
                            grid: { color: 'var(--md-sys-color-outline-variant)' }
                        },
                        x: {
                            ticks: { color: 'var(--color-text-secondary)' },
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: { 
                            labels: { color: 'var(--color-text-secondary)' } 
                        }
                    }
                }
            });
        }

        // --- Gráfico de Status da Frota (Rosca) ---
        const fleetStatusCtx = document.getElementById('fleet-status-chart')?.getContext('2d');
        if (fleetStatusCtx) {
            this.charts.fleetStatusChart = new Chart(fleetStatusCtx, {
                type: 'doughnut',
                data: {
                    labels: ['Operacional', 'Manutenção', 'Inativo'],
                    datasets: [{
                        label: 'Status da Frota',
                        data: [38, 3, 4],
                        backgroundColor: [
                            'var(--md-sys-color-success)',
                            'var(--md-sys-color-warning)',
                            'var(--md-sys-color-error)'
                        ],
                        borderColor: 'var(--md-sys-color-surface-container)',
                        borderWidth: 4,
                        hoverOffset: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '70%',
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { color: 'var(--color-text-secondary)', padding: 20 }
                        }
                    }
                }
            });
        }
    },

    render(container) {
        container.innerHTML = `
            <div class="page-header section-header-standardized">
                <h1 class="page-title section-title-standardized"  style="margin-top: 0; margin-left: 0">
                    <i class="fas fa-tachometer-alt"></i> Dashboard
                </h1>
                <p class="page-subtitle">Visão geral do sistema de transporte escolar</p>
            </div>
            <div class="compliance-banner">
                <div class="neural-background"></div>
                <div class="compliance-content section-content-standardized">
                    <i class="fas fa-brain compliance-icon"></i>
                    <div class="compliance-text">
                        <h3>Sistema Neural de Conformidade Ativo</h3>
                        <p>IA monitorando continuamente GCOTE, LGPD e Portarias SEEDF em tempo real</p>
                    </div>
                </div>
            </div>
            <div class="w-full cards-grid">
                <div class="card metric-card primary">
                    <div class="card-body">
                        <div class="stat-header">
                            <span class="stat-title">Alunos Ativos</span>
                            <div class="stat-icon primary"><i class="fas fa-graduation-cap"></i></div>
                        </div>
                        <div class="stat-value">1,247</div>
                        <div class="stat-change positive"><i class="fas fa-arrow-up"></i><span>+3.2% este mês</span></div>
                    </div>
                </div>
                <div class="card metric-card success">
                    <div class="card-body">
                        <div class="stat-header">
                            <span class="stat-title">Rotas Ativas</span>
                            <div class="stat-icon success"><i class="fas fa-route"></i></div>
                        </div>
                        <div class="stat-value">23</div>
                        <div class="stat-change positive"><i class="fas fa-arrow-up"></i><span>+2 novas rotas</span></div>
                    </div>
                </div>
                <div class="card metric-card warning">
                    <div class="card-body">
                        <div class="stat-header">
                            <span class="stat-title">Veículos</span>
                            <div class="stat-icon warning"><i class="fas fa-bus"></i></div>
                        </div>
                        <div class="stat-value">45</div>
                        <div class="stat-change neutral"><i class="fas fa-minus"></i><span>2 em manutenção</span></div>
                    </div>
                </div>
                <div class="card metric-card error">
                    <div class="card-body">
                        <div class="stat-header">
                            <span class="stat-title">Incidentes</span>
                            <div class="stat-icon error"><i class="fas fa-exclamation-triangle"></i></div>
                        </div>
                        <div class="stat-value">3</div>
                        <div class="stat-change negative"><i class="fas fa-arrow-down"></i><span>-2 resolvidos</span></div>
                    </div>
                </div>
            </div>
            <div class="w-full cards-grid"  style="grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); margin-top: var(--space-6)">
                <div class="card">
                    <div class="card-header"><h3 class="card-title"><i class="fas fa-chart-line"></i> Frequência Semanal</h3></div>
                    <div class="card-body"><canvas id="attendance-chart"></canvas></div>
                </div>
                <div class="card">
                    <div class="card-header"><h3 class="card-title"><i class="fas fa-chart-pie"></i> Status da Frota</h3></div>
                    <div class="card-body"><canvas id="fleet-status-chart"></canvas></div>
                </div>
            </div>
        `;
    }
};

// ============================================================================
// MAP MANAGER
// ============================================================================
const MapManager = {
    map: null,
 isInitialized: false,

 init(container) {
 if (this.isInitialized) return;
                console.log('[MapManager] Inicializando Mapa.');
 this.render(container);
 // Adia a renderização para garantir que o DOM e a lib estejam prontos
 setTimeout(() => this.renderMap(), 100);
 this.isInitialized = true;
 },

 render(container) {
 container.innerHTML = `
                    <div class="page-header section-header-standardized">
                        <h2 class="page-title"><i class="fas fa-map-marked-alt"></i> Monitoramento em Tempo Real</h2>
                        <p class="page-subtitle">Acompanhe a localização dos veículos e pontos de parada em tempo real.</p>
 </div>

                    <div class="w-full stats-grid">
                        <div class="card metric-card primary"><div class="card-body"><div class="stat-header"><div class="stat-title">Rotas Ativas</div><div class="stat-icon primary"><i class="fas fa-route"></i></div></div><div class="stat-value">5</div></div></div>
                        <div class="card metric-card success"><div class="card-body"><div class="stat-header"><div class="stat-title">Veículos em Operação</div><div class="stat-icon success"><i class="fas fa-bus"></i></div></div><div class="stat-value">5</div></div></div>
                        <div class="card metric-card warning"><div class="card-body"><div class="stat-header"><div class="stat-title">Atrasos</div><div class="stat-icon warning"><i class="fas fa-clock"></i></div></div><div class="stat-value">3</div></div></div>
                        <div class="card metric-card error"><div class="card-body"><div class="stat-header"><div class="stat-title">Incidentes</div><div class="stat-icon error"><i class="fas fa-exclamation-triangle"></i></div></div><div class="stat-value">1</div></div></div>
 </div>

                    <div class="card"  style="margin-top: var(--space-6)">
                        <div class="card-header">
                            <h3 class="card-title section-title-standardized"><i class="fas fa-map"></i> Mapa Interativo</h3>
                            <div class="crud-actions">
                                <button class="btn btn-sm btn-secondary"><i class="fas fa-layer-group"></i> Camadas</button>
                                <button class="btn btn-sm btn-primary" onclick="MapManager.centerMap()"><i class="fas fa-crosshairs"></i> Centralizar</button>
 </div>
 </div>
                        <div class="card-body"  style="padding:0; height: 60vh">
                            <div id="map-canvas"  style="height: 100%; width: 100%"></div>
 </div>
 </div>

                    <div class="card"  style="margin-top: var(--space-6)">
                        <div class="card-header">
                            <h3 class="card-title section-title-standardized"><i class="fas fa-map-pin"></i> Pontos de Parada por Rota</h3>
 </div>
                        <div class="card-body">
                            <div id="map-table-container"></div>
 </div>
 </div>
 `;
 },

 renderMap() {
 if (this.map) {
 this.map.remove();
 }

                const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
 const tileUrl = isDarkMode
                    ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
                    : 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';

                this.map = L.map('map-canvas').setView([-15.7942, -47.8825], 11); // Brasília

 L.tileLayer(tileUrl, {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
 }).addTo(this.map);

 // Marcadores de Veículos (Simulado)
 const vehicleIcon = L.divIcon({
                    html: '<i class="fas fa-bus"  style="color: var(--md-sys-color-primary); font-size: 24px; text-shadow: 0 0 3px #fff"></i>',
                    className: 'map-vehicle-icon',
 iconSize: [24, 24],
 iconAnchor: [12, 24]
 });
                L.marker([-15.7801, -47.9292], { icon: vehicleIcon }).addTo(this.map).bindPopup("<b>Veículo 101</b><br>Rota 01 - 45km/h");
                L.marker([-15.8345, -47.9452], { icon: vehicleIcon }).addTo(this.map).bindPopup("<b>Veículo 102</b><br>Rota 02 - 52km/h");

 // Marcadores de Pontos de Parada (Simulado)
 const stopIcon = L.divIcon({
                    html: '<i class="fas fa-map-pin"  style="color: var(--md-sys-color-error); font-size: 20px"></i>',
                    className: 'map-stop-icon',
 iconSize: [20, 20],
 iconAnchor: [10, 20]
 });
                L.marker([-15.7998, -47.8645], { icon: stopIcon }).addTo(this.map).bindPopup("<b>Ponto 01</b><br>Embarque/Desembarque");
                L.marker([-15.8123, -47.8789], { icon: stopIcon }).addTo(this.map).bindPopup("<b>Ponto 02</b><br>Embarque");

 this.renderTable();
 },

 centerMap() {
 if (this.map) {
 this.map.setView([-15.7942, -47.8825], 11);
 }
 },

 async renderTable() {
 try {
            // Carrega pontos reais da planilha Mapa
            let pontos = [];
            if (window.DataLoader) {
                pontos = await DataLoader.load('Mapa', {}, false);
            }

            const columns = [
                { label: 'ID', field: 'ID' },
                { label: 'Nome do Ponto', field: 'Nome_Ponto' },
                { label: 'Tipo', field: 'Tipo' },
                { label: 'Rota', field: 'Rota_ID' },
                { label: 'Ordem', field: 'Ordem_Parada' },
                {
                    label: 'Ações',
                    render: (row) => `<div class="table-actions">
                        <button aria-label="Editar" class="btn-icon btn-sm" onclick="MapManager.editPoint('${row.ID}')" title="Editar"><i class="fas fa-pencil-alt"></i></button>
                        <button aria-label="Excluir" class="btn-icon btn-sm btn-error" onclick="MapManager.deletePoint('${row.ID}')" title="Excluir"><i class="fas fa-trash"></i></button>
                    </div>`
                }
            ];

            TableRenderer.render('map-table-container', pontos, columns, {
                emptyMessage: 'Nenhum ponto de parada encontrado.'
            });

            if (window.ToastManager && pontos.length > 0) {
                ToastManager.show(`${pontos.length} pontos carregados`, 'success', 2000);
            }
        } catch (error) {
            console.error('[MapManager] Erro ao carregar pontos:', error);
            if (window.ToastManager) {
                ToastManager.show('Erro ao carregar pontos do mapa', 'error', 3000);
            }
        }
    },

    editPoint(pointId) {
        console.log('[MapManager] Editar ponto:', pointId);
        ToastManager.show('Funcionalidade de edição em desenvolvimento', 'info', 2000);
    },

    deletePoint(pointId) {
        console.log('[MapManager] Excluir ponto:', pointId);
        if (confirm('Deseja realmente excluir este ponto?')) {
            ToastManager.show('Funcionalidade de exclusão em desenvolvimento', 'info', 2000);
        }
    }
 };

 // ============================================================================
 // KANBAN MANAGER
 // ============================================================================
 const KanbanManager = {
 isInitialized: false,
 data: [],
            columns: ['Pendente', 'Em Andamento', 'Concluído'],

 init(container) {
 if (this.isInitialized) return;
                console.log('[KanbanManager] Inicializando Kanban.');
 this.render(container);
 this.loadAndRenderCards();
 this.isInitialized = true;
 },

 render(container) {
 container.innerHTML = `
                    <div class="page-header">
                        <h2 class="page-title"><i class="fas fa-columns"></i> Quadro Kanban de Processos</h2>
                        <p class="page-subtitle">Gerencie o fluxo de trabalho dos processos SEI de forma visual e interativa.</p>
 </div>
                    <div class="kanban-board" id="kanban-board">
 ${this.columns.map(col => `
                            <div class="kanban-column" data-column-status="${col}">
                                <div class="kanban-column-header">
 <h4>${col}</h4>
                                    <span class="badge" id="count-${col.replace(/\s+/g, '')}">0</span>
 </div>
                                <div class="kanban-cards">
 <!-- Cards will be rendered here -->
 </div>
 </div>
                        `).join('')}
 </div>
 `;
 this.setupDragAndDrop();
 },

 loadAndRenderCards() {
 // Reutiliza os dados já carregados pelo CRUDManager
                const crudInstance = CRUDManagerUniversal.instances['kanban'];
 if (crudInstance && crudInstance.data) {
 this.data = crudInstance.data;
 this.renderCards();
 } else {
                    console.warn('[KanbanManager] Dados do CRUD para Kanban não encontrados. O quadro pode estar vazio.');
 }
 },

 renderCards() {
 this.columns.forEach(col => {
                    const columnEl = document.querySelector(`.kanban-column[data-column-status="${col}"] .kanban-cards`);
                    const countEl = document.getElementById(`count-${col.replace(/\s+/g, '')}`);
 if (!columnEl || !countEl) return;

 const cardsForColumn = this.data.filter(item => item.status === col);
 columnEl.innerHTML = cardsForColumn.map(item => `
                        <div class="kanban-card" draggable="true" data-card-id="${item.ID}">
 <h5>${item.numero_sei}</h5>
 <p>${item.assunto}</p>
                            <div class="card-meta">
                                <span class="card-priority ${item.prioridade || 'low'}">${item.prioridade || 'Baixa'}</span>
                                <span class="card-date"><i class="fas fa-user"></i> ${item.responsavel}</span>
 </div>
 </div>
                    `).join('');
 countEl.textContent = cardsForColumn.length;
 });
 },

 setupDragAndDrop() {
                const board = document.getElementById('kanban-board');
 if (!board) return;

 let draggedCard = null;

                board.addEventListener('dragstart', e => {
                    if (e.target.classList.contains('kanban-card')) {
 draggedCard = e.target;
 setTimeout(() => {
                            e.target.classList.add('is-dragging');
 }, 0);
 }
 });

                board.addEventListener('dragend', e => {
 if (draggedCard) {
                        draggedCard.classList.remove('is-dragging');
 draggedCard = null;
 }
 });

                board.addEventListener('dragover', e => {
 e.preventDefault();
                    const column = e.target.closest('.kanban-column');
 if (column) {
 // Lógica para posicionar placeholder (opcional, mais avançado)
                        column.classList.add('is-over');
 }
 });

                board.addEventListener('dragleave', e => {
                    const column = e.target.closest('.kanban-column');
 if (column) {
                        column.classList.remove('is-over');
 }
 });

                board.addEventListener('drop', e => {
 e.preventDefault();
                    const column = e.target.closest('.kanban-column');
 if (column && draggedCard) {
                        column.classList.remove('is-over');
 const newStatus = column.dataset.columnStatus;
 const cardId = draggedCard.dataset.cardId;

 // Update data model
 const cardData = this.data.find(item => String(item.ID) === cardId);
 if (cardData && cardData.status !== newStatus) {
 cardData.status = newStatus;
 console.log(`[Kanban] Card ${cardId} movido para ${newStatus}`);

 // Opcional: Chamar API para salvar a mudança no backend
                            // API.run('updateRecord', { sheetName: 'Processos', id: cardId, data: { status: newStatus } });

                            ToastManager.show(`Processo ${cardData.numero_sei} movido para "${newStatus}".`, 'success');
 }

 // Re-render a UI
 this.renderCards();
 }
 });
 }
 };

 // ============================================================================
 // HANDLERS CUSTOMIZADOS PARA SEÇÕES ESPECIAIS
 // ============================================================================

 /**
 * Mapeamento de seções que requerem lógica customizada (não-CRUD).
 * Todas as outras seções serão configuradas automaticamente via SheetMappingManager.
 * Versão: 3.0 - Data-Driven Architecture
 */
 const CUSTOM_SECTION_HANDLERS = {
 // 1. FREQUÊNCIA - Já tem implementação customizada em AttendanceManager

            'eventos': {
                title: 'Eventos',
                searchPlaceholder: 'Buscar eventos...',
 columns: [
                    { label: 'Título', field: 'titulo' },
                    { label: 'Data', field: 'data' },
                    { label: 'Tipo', field: 'tipo' },
 {
                        label: 'Status',
                        render: (row) => `<span class="status-badge ${row.status?.toLowerCase()}">${row.status}</span>`
 }
 ],
 fields: [
                    { name: 'titulo', label: 'Título do Evento', type: 'text', required: true },
                    { name: 'descricao', label: 'Descrição', type: 'textarea', rows: 3, required: true },
                    { name: 'data', label: 'Data', type: 'date', required: true },
                    { name: 'hora_inicio', label: 'Hora Início', type: 'time', required: true },
                    { name: 'hora_fim', label: 'Hora Fim', type: 'time' },
 {
                        name: 'tipo',
                        label: 'Tipo de Evento',
                        type: 'select',
                        options: ['Passeio', 'Atividade Extracurricular', 'Reunião', 'Manutenção', 'Outro'],
 required: true
 },
 {
                        name: 'status',
                        label: 'Status',
                        type: 'select',
 options: [
                            { value: 'active', label: 'Ativo' },
                            { value: 'inactive', label: 'Cancelado' }
 ],
 required: true
 }
 ]
 },

            'pessoal': {
                title: 'Gestão de Pessoal',
                formUrl: 'Form-Pessoal', // Carrega formulário customizado dinamicamente
                searchPlaceholder: 'Buscar funcionários...',
 columns: [
                    { label: 'Nome', field: 'Nome_Completo' },
                    { label: 'Cargo', field: 'Cargo' },
                    { label: 'CPF', field: 'CPF' },
                    { label: 'Telefone', field: 'Telefone' },
 {
                        label: 'Status',
                        render: (row) => `<span class="status-badge ${row.Status_Contrato?.toLowerCase()}">${row.Status_Contrato}</span>`
 }
 ]
                // fields removido - formulário será carregado via formUrl
 },

            'alunos': {
                title: 'Alunos',
                formUrl: 'Form-Alunos', // Carrega formulário customizado dinamicamente
                searchPlaceholder: 'Buscar alunos...',
 columns: [
                    { label: 'Nome', field: 'Nome_Completo' },
                    { label: 'RA', field: 'RA_Aluno' },
                    { label: 'Escola', field: 'Escola' },
                    { label: 'Rota', field: 'ID_Rota' },
 {
                        label: 'Status',
                        render: (row) => `<span class="status-badge ${row.Status_Ativo?.toLowerCase()}">${row.Status_Ativo}</span>`
 }
 ]
                // fields removido - formulário será carregado via formUrl
 },

            'rotas': {
                title: 'Rotas',
                formUrl: 'Form-Rotas', // Carrega formulário customizado dinamicamente
                searchPlaceholder: 'Buscar rotas...',
 columns: [
                    { label: 'Nome da Rota', field: 'Nome_Rota' },
                    { label: 'Código', field: 'Codigo' },
                    { label: 'Veículo', field: 'Veiculo_ID' },
                    { label: 'Motorista', field: 'Motorista_ID' },
 {
                        label: 'Status',
                        render: (row) => `<span class="status-badge ${row.Status?.toLowerCase()}">${row.Status}</span>`
 }
 ]
                // fields removido - formulário será carregado via formUrl
 },

            'veiculos': {
                title: 'Veículos',
                formUrl: 'Form-Veiculos', // Carrega formulário customizado dinamicamente
                searchPlaceholder: 'Buscar veículos...',
 columns: [
                    { label: 'Placa', field: 'Placa' },
                    { label: 'Modelo', field: 'Modelo' },
                    { label: 'Capacidade', field: 'Capacidade_Total' },
                    { label: 'Marca', field: 'Marca' },
 {
                        label: 'Status',
                        render: (row) => `<span class="status-badge ${row.Status?.toLowerCase()}">${row.Status}</span>`
 }
 ]
                // fields removido - formulário será carregado via formUrl
 },

            'predictive-maintenance': {
                title: 'Manutenção Preditiva',
                searchPlaceholder: 'Buscar manutenções...',
 columns: [
                    { label: 'Veículo', field: 'veiculo' },
                    { label: 'Tipo', field: 'tipo' },
                    { label: 'Data Prevista', field: 'data_prevista' },
 {
                        label: 'Prioridade',
                        render: (row) => `<span class="status-badge ${row.prioridade?.toLowerCase()}">${row.prioridade}</span>`
 }
 ],
 fields: [
                    { name: 'veiculo', label: 'Veículo/Placa', type: 'text', required: true },
 {
                        name: 'tipo',
                        label: 'Tipo de Manutenção',
                        type: 'select',
                        options: ['Preventiva', 'Corretiva', 'Preditiva'],
 required: true
 },
                    { name: 'descricao', label: 'Descrição do Serviço', type: 'textarea', rows: 3, required: true, placeholder: 'Ex: Troca de óleo e filtros, verificação de freios...' },
                    { name: 'data_prevista', label: 'Data Prevista', type: 'date', required: true },
                    { name: 'km_previsto', label: 'KM Previsto', type: 'number' },
                    { name: 'fornecedor', label: 'Fornecedor/Oficina', type: 'text' },
                    { name: 'custo_estimado', label: 'Custo Estimado (R$)', type: 'number', step: '0.01' },
 {
                        name: 'prioridade',
                        label: 'Prioridade',
                        type: 'select',
 options: [
                            { value: 'error', label: 'Alta' },
                            { value: 'warning', label: 'Média' },
                            { value: 'info', label: 'Baixa' }
 ],
 required: true
 },
                    { name: 'observacoes', label: 'Observações', type: 'textarea', rows: 2 }
 ]
 },

            'gamification': {
                title: 'Sistema de Gamificação',
                searchPlaceholder: 'Buscar conquistas...',
 columns: [
                    { label: 'Aluno', field: 'aluno' },
                    { label: 'Pontos', field: 'pontos' },
                    { label: 'Nível', field: 'nivel' },
                    { label: 'Conquistas', field: 'conquistas' }
 ],
 fields: [
                    { name: 'aluno', label: 'Aluno', type: 'text', required: true },
                    { name: 'pontos', label: 'Pontos Acumulados', type: 'number', min: '0', default: '0' },
                    { name: 'nivel', label: 'Nível Atual', type: 'number', min: '1', default: '1' },
                    { name: 'conquistas', label: 'Conquistas Desbloqueadas', type: 'textarea', rows: 3 },
                    { name: 'ultima_atualizacao', label: 'Última Atualização', type: 'date' }
 ]
 },

 // E assim por diante para as 24 seções...
            'kanban_example': { // Exemplo para Kanban (renomeado)
                title: 'Processos SEI',
                searchPlaceholder: 'Buscar processos...',
 columns: [
                    { label: 'Número SEI', field: 'numero_sei' },
                    { label: 'Assunto', field: 'assunto' },
                    { label: 'Responsável', field: 'responsavel' },
 {
                        label: 'Status',
                        render: (row) => `<span class="status-badge ${row.status?.toLowerCase()}">${row.status}</span>`
 }
 ],
 fields: [
                    { name: 'numero_sei', label: 'Número do Processo SEI', type: 'text', required: true, placeholder: 'Ex: 00080-00123456/2024-00' },
                    { name: 'assunto', label: 'Assunto', type: 'text', required: true },
                    { name: 'descricao', label: 'Descrição', type: 'textarea', rows: 3 },
                    { name: 'responsavel', label: 'Responsável', type: 'text', required: true },
                    { name: 'data_abertura', label: 'Data de Abertura', type: 'date', required: true },
                    { name: 'prazo', label: 'Prazo', type: 'date' },
 {
                        name: 'status',
                        label: 'Status',
                        type: 'select',
 options: [
                            { value: 'info', label: 'Pendente' },
                            { value: 'warning', label: 'Em Andamento' },
                            { value: 'active', label: 'Concluído' }
 ],
 required: true
 }
 ]
 },

            'compliance-validation': {
                title: 'Validação de Conformidade',
                searchPlaceholder: 'Buscar validações...',
 columns: [
                    { label: 'Categoria', field: 'Categoria' },
                    { label: 'Item', field: 'Item_Verificacao' },
                    { label: 'Data', field: 'Data_Verificacao' },
 {
                        label: 'Status',
                        render: (row) => `<span class="status-badge ${row.Status?.toLowerCase()}">${row.Status}</span>`
 }
 ],
 fields: [
                    { name: 'Categoria', label: 'Categoria', type: 'text', required: true },
                    { name: 'Item_Verificacao', label: 'Item de Verificação', type: 'text', required: true, helpText: 'Descreva o item específico que está sendo validado.' },
                    { name: 'Data_Verificacao', label: 'Data de Verificação', type: 'date', required: true },
                    { name: 'Responsavel', label: 'Responsável', type: 'text', required: true },
                    { name: 'Observacoes', label: 'Observações', type: 'textarea', rows: 3 },
                    { name: 'Acao_Corretiva', label: 'Ação Corretiva', type: 'textarea', rows: 2 },
                    { name: 'Prazo_Correcao', label: 'Prazo para Correção', type: 'date' },
 {
                        name: 'Status',
                        label: 'Status',
                        type: 'select',
                        options: ['Conforme', 'Não Conforme', 'Em Análise'],
 required: true
 }
 ]
 },

            'tracking': {
                title: 'Rastreamento',
                searchPlaceholder: 'Buscar rastreamentos...',
 columns: [
                    { label: 'Veículo', field: 'Veiculo_ID' },
                    { label: 'Timestamp', field: 'Timestamp' },
                    { label: 'Velocidade', field: 'Velocidade' },
                    { label: 'Status', field: 'Status_Motor' }
 ],
 fields: [
                    { name: 'Veiculo_ID', label: 'ID do Veículo', type: 'text', required: true },
                    { name: 'Latitude', label: 'Latitude', type: 'text', required: true },
                    { name: 'Longitude', label: 'Longitude', type: 'text', required: true },
                    { name: 'Velocidade', label: 'Velocidade (km/h)', type: 'number', min: '0' },
                    { name: 'Status_Motor', label: 'Status Motor', type: 'select', options: ['Ligado', 'Desligado'], required: true },
                    { name: 'Combustivel_Nivel', label: 'Combustível (%)', type: 'number', min: '0', max: '100' },
                    { name: 'Rota_Ativa', label: 'Rota Ativa', type: 'text' }
 ]
 },

            'utilizacao-frota': {
                title: 'Utilização da Frota',
                searchPlaceholder: 'Buscar registros...',
 columns: [
                    { label: 'Data', field: 'Data' },
                    { label: 'Veículo', field: 'Veiculo_ID' },
                    { label: 'KM', field: 'KM_Rodados' },
                    { label: 'Alunos', field: 'Alunos_Transportados' }
 ],
 fields: [
                    { name: 'Data', label: 'Data', type: 'date', required: true },
                    { name: 'Veiculo_ID', label: 'ID Veículo', type: 'text', required: true },
                    { name: 'KM_Inicial', label: 'KM Inicial', type: 'number', required: true },
                    { name: 'KM_Final', label: 'KM Final', type: 'number', required: true },
                    { name: 'Horas_Operacao', label: 'Horas', type: 'number' },
                    { name: 'Alunos_Transportados', label: 'Alunos', type: 'number', min: '0' },
                    { name: 'Observacoes', label: 'Observações', type: 'textarea', rows: 2 }
 ]
 },

            'faturamentos': {
                title: 'Faturamentos',
                searchPlaceholder: 'Buscar faturamentos...',
 columns: [
                    { label: 'Mês', field: 'Mes_Referencia' },
                    { label: 'Aluno', field: 'Aluno_ID' },
                    { label: 'Valor', field: 'Valor_Mensalidade' },
                    { label: 'Status', field: 'Status_Pagamento' }
 ],
 fields: [
                    { name: 'Mes_Referencia', label: 'Mês Referência', type: 'month', required: true, helpText: 'Selecione o mês e ano de referência da fatura.' },
                    { name: 'Aluno_ID', label: 'ID Aluno', type: 'text', required: true },
                    { name: 'Valor_Mensalidade', label: 'Valor (R$)', type: 'number', step: '0.01', required: true },
                    { name: 'Data_Vencimento', label: 'Vencimento', type: 'date', required: true },
                    { name: 'Data_Pagamento', label: 'Pagamento', type: 'date' },
                    { name: 'Status_Pagamento', label: 'Status', type: 'select', options: ['Pendente', 'Pago', 'Atrasado'], required: true },
                    { name: 'Forma_Pagamento', label: 'Forma', type: 'select', options: ['Boleto', 'PIX', 'Transferência'] }
 ]
 },

            'atestos': {
                title: 'Atestos',
                searchPlaceholder: 'Buscar atestos...',
 columns: [
                    { label: 'Aluno', field: 'Aluno_ID' },
                    { label: 'Tipo', field: 'Tipo_Confirmacao' },
                    { label: 'Data', field: 'Data_Inicio' },
                    { label: 'Status', field: 'Status' }
 ],
 fields: [
                    { name: 'Aluno_ID', label: 'ID Aluno', type: 'text', required: true },
                    { name: 'Tipo_Confirmacao', label: 'Tipo', type: 'select', options: ['Atestado Médico', 'Justificativa', 'Ausência Autorizada'], required: true },
                    { name: 'Data_Inicio', label: 'Data Início', type: 'date', required: true, helpText: 'Data de início da validade do atesto/justificativa.' },
                    { name: 'Data_Fim', label: 'Data Fim', type: 'date', required: true },
                    { name: 'Motivo', label: 'Motivo', type: 'textarea', rows: 3, required: true },
                    { name: 'Unidade_Ensino', label: 'Unidade', type: 'text' },
                    { name: 'Status', label: 'Status', type: 'select', options: ['Pendente', 'Aprovado', 'Rejeitado'], required: true }
 ]
 },

            'relatorios': {
                title: 'Relatórios',
                searchPlaceholder: 'Buscar relatórios...',
 columns: [
                    { label: 'Nome', field: 'Nome' },
                    { label: 'Tipo', field: 'Tipo_Relatorio' },
                    { label: 'Data', field: 'Data_Geracao' },
                    { label: 'Status', field: 'Status' }
 ],
 fields: [
                    { name: 'Tipo_Relatorio', label: 'Tipo', type: 'select', options: ['Frequência', 'Frota', 'Financeiro', 'Operacional'], required: true },
                    { name: 'Nome', label: 'Nome', type: 'text', required: true, placeholder: 'Ex: Relatório Mensal de Frequência - Out/24' },
                    { name: 'Data_Geracao', label: 'Data', type: 'date', required: true },
                    { name: 'Usuario_Solicitante', label: 'Solicitante', type: 'text', required: true },
                    { name: 'Status', label: 'Status', type: 'select', options: ['Processando', 'Concluído', 'Erro'], required: true },
                    { name: 'Formato_Arquivo', label: 'Formato', type: 'select', options: ['PDF', 'Excel', 'CSV'] }
 ]
 },

            'ai-reports': {
                title: 'Relatórios IA',
                searchPlaceholder: 'Buscar análises...',
 columns: [
                    { label: 'Tipo', field: 'Tipo_Analise' },
                    { label: 'Algoritmo', field: 'Algoritmo_Usado' },
                    { label: 'Data', field: 'Data_Processamento' },
                    { label: 'Confiança', field: 'Confianca_Score' }
 ],
 fields: [
                    { name: 'Tipo_Analise', label: 'Tipo', type: 'select', options: ['Preditiva', 'Descritiva', 'Prescritiva'], required: true },
                    { name: 'Algoritmo_Usado', label: 'Algoritmo', type: 'select', options: ['Machine Learning', 'Deep Learning', 'Regressão'], required: true },
                    { name: 'Resultado', label: 'Resultado', type: 'textarea', rows: 4, required: true, helpText: 'Resumo dos insights gerados pela IA.' },
                    { name: 'Confianca_Score', label: 'Confiança (%)', type: 'number', min: '0', max: '100', required: true },
                    { name: 'Recomendacoes', label: 'Recomendações', type: 'textarea', rows: 3 },
                    { name: 'Status', label: 'Status', type: 'select', options: ['Processando', 'Concluído', 'Erro'], required: true }
 ]
 },

            'engagement': {
                title: 'Engajamento',
                searchPlaceholder: 'Buscar interações...',
 columns: [
                    { label: 'Usuário', field: 'Usuario_ID' },
                    { label: 'Tipo', field: 'Tipo_Usuario' },
                    { label: 'Ação', field: 'Acao' },
                    { label: 'Seção', field: 'Secao_Sistema' }
 ],
 fields: [
                    { name: 'Usuario_ID', label: 'ID Usuário', type: 'text', required: true },
                    { name: 'Tipo_Usuario', label: 'Tipo', type: 'select', options: ['Admin', 'Secretário', 'Monitor', 'Responsável'], required: true },
                    { name: 'Acao', label: 'Ação', type: 'text', required: true },
                    { name: 'Secao_Sistema', label: 'Seção', type: 'text', required: true },
                    { name: 'Dispositivo', label: 'Dispositivo', type: 'select', options: ['Desktop', 'Mobile', 'Tablet'] },
                    { name: 'Satisfacao_Score', label: 'Satisfação (1-5)', type: 'number', min: '1', max: '5' },
                    { name: 'Feedback', label: 'Feedback', type: 'textarea', rows: 3 }
 ]
 },

            'incidentes': {
                title: 'Incidentes',
                searchPlaceholder: 'Buscar incidentes...',
 columns: [
                    { label: 'Tipo', field: 'Tipo_Incidente' },
                    { label: 'Severidade', field: 'Severidade' },
                    { label: 'Data', field: 'Data_Ocorrencia' },
                    { label: 'Status', field: 'Status' }
 ],
 fields: [
                    { name: 'Tipo_Incidente', label: 'Tipo', type: 'select', options: ['Acidente', 'Pane Mecânica', 'Atraso', 'Comportamento', 'Outro'], required: true },
                    { name: 'Severidade', label: 'Severidade', type: 'select', options: ['Crítica', 'Alta', 'Média', 'Baixa'], required: true },
                    { name: 'Data_Ocorrencia', label: 'Data', type: 'date', required: true },
                    { name: 'Veiculo_ID', label: 'ID Veículo', type: 'text' },
                    { name: 'Rota_ID', label: 'ID Rota', type: 'text' },
                    { name: 'Motorista_ID', label: 'ID Motorista', type: 'text' },
                    { name: 'Descricao', label: 'Descrição', type: 'textarea', rows: 4, required: true },
                    { name: 'Acao_Tomada', label: 'Ação Tomada', type: 'textarea', rows: 3 },
                    { name: 'Status', label: 'Status', type: 'select', options: ['Aberto', 'Em Análise', 'Resolvido', 'Fechado'], required: true }
 ]
 },

            'whatsapp': {
                title: 'WhatsApp',
                searchPlaceholder: 'Buscar mensagens...',
 columns: [
                    { label: 'Destinatário', field: 'Destinatario' },
                    { label: 'Tipo', field: 'Tipo_Mensagem' },
                    { label: 'Data', field: 'Data_Envio' },
                    { label: 'Status', field: 'Status_Envio' }
 ],
 fields: [
                    { name: 'Destinatario', label: 'Destinatário', type: 'tel', required: true, placeholder: '+5561999999999' },
                    { name: 'Tipo_Mensagem', label: 'Tipo', type: 'select', options: ['Texto', 'Imagem', 'Documento', 'Template'], required: true, helpText: 'Templates são mensagens pré-aprovadas.' },
                    { name: 'Conteudo', label: 'Conteúdo', type: 'textarea', rows: 4, required: true },
                    { name: 'Status_Envio', label: 'Status', type: 'select', options: ['Pendente', 'Enviado', 'Entregue', 'Lido', 'Erro'], required: true },
                    { name: 'Data_Envio', label: 'Data Envio', type: 'date' },
                    { name: 'Campanha', label: 'Campanha', type: 'text' },
                    { name: 'Rota_ID', label: 'ID Rota', type: 'text' }
 ]
 },

            'mcp-server': {
                title: 'MCP Server',
                searchPlaceholder: 'Buscar conexões...',
 columns: [
                    { label: 'Tipo', field: 'Tipo_Conexao' },
                    { label: 'Endpoint', field: 'Endpoint' },
                    { label: 'Status', field: 'Status' },
                    { label: 'Última Sync', field: 'Ultima_Sincronizacao' }
 ],
 fields: [
                    { name: 'Tipo_Conexao', label: 'Tipo', type: 'select', options: ['API', 'WebSocket', 'Database', 'File'], required: true },
                    { name: 'Endpoint', label: 'Endpoint', type: 'text', required: true, placeholder: 'Ex: https://api.example.com/data' },
                    { name: 'Status', label: 'Status', type: 'select', options: ['Conectado', 'Desconectado', 'Erro'], required: true },
                    { name: 'Ultima_Sincronizacao', label: 'Última Sync', type: 'datetime-local' },
                    { name: 'Dados_Sincronizados', label: 'Dados Sync', type: 'number', min: '0' },
                    { name: 'Latencia_MS', label: 'Latência (ms)', type: 'number', min: '0' },
                    { name: 'Taxa_Sucesso', label: 'Taxa Sucesso (%)', type: 'number', min: '0', max: '100' },
                    { name: 'Configuracao', label: 'Configuração', type: 'textarea', rows: 3 }
 ]
 },

            'automacoes': {
                title: 'Automações',
                searchPlaceholder: 'Buscar automações...',
 columns: [
                    { label: 'Nome', field: 'Nome_Automacao' },
                    { label: 'Tipo', field: 'Tipo' },
                    { label: 'Trigger', field: 'Trigger' },
                    { label: 'Status', field: 'Status' }
 ],
 fields: [
                    { name: 'Nome_Automacao', label: 'Nome', type: 'text', required: true },
                    { name: 'Tipo', label: 'Tipo', type: 'select', options: ['Agendada', 'Evento', 'Condicional', 'Manual'], required: true },
                    { name: 'Trigger', label: 'Gatilho', type: 'text', required: true, helpText: 'Ex: "Diariamente às 23h", "Ao criar novo aluno".' },
                    { name: 'Condicoes', label: 'Condições', type: 'textarea', rows: 3 },
                    { name: 'Acoes', label: 'Ações', type: 'textarea', rows: 3, required: true },
                    { name: 'Status', label: 'Status', type: 'select', options: ['Ativa', 'Inativa', 'Pausada'], required: true },
                    { name: 'Frequencia_Execucao', label: 'Frequência', type: 'select', options: ['Única', 'Diária', 'Semanal', 'Mensal'] },
                    { name: 'Ultima_Execucao', label: 'Última Execução', type: 'datetime-local' },
                    { name: 'Proxima_Execucao', label: 'Próxima Execução', type: 'datetime-local' },
                    { name: 'Responsavel', label: 'Responsável', type: 'text' }
 ]
 },

            'configuracoes': {
                title: 'Configurações',
                searchPlaceholder: 'Buscar configurações...',
 columns: [
                    { label: 'Categoria', field: 'Categoria' },
                    { label: 'Chave', field: 'Chave' },
                    { label: 'Valor', field: 'Valor' },
                    { label: 'Última Alteração', field: 'Data_Alteracao' }
 ],
 fields: [
                    { name: 'Categoria', label: 'Categoria', type: 'select', options: ['Sistema', 'Interface', 'Segurança', 'Integração', 'Notificação'], required: true },
                    { name: 'Chave', label: 'Chave', type: 'text', required: true, placeholder: 'Ex: system.theme.default' },
                    { name: 'Valor', label: 'Valor', type: 'text', required: true },
                    { name: 'Tipo_Dados', label: 'Tipo de Dados', type: 'select', options: ['String', 'Number', 'Boolean', 'JSON', 'Array'] },
                    { name: 'Descricao', label: 'Descrição', type: 'textarea', rows: 2 },
                    { name: 'Usuario_Alteracao', label: 'Usuário', type: 'text' },
                    { name: 'Data_Alteracao', label: 'Data Alteração', type: 'date' },
                    { name: 'Valor_Anterior', label: 'Valor Anterior', type: 'text' },
                    { name: 'Observacoes', label: 'Observações', type: 'textarea', rows: 2 },
                    { name: 'Requer_Reinicio', label: 'Requer Reinício', type: 'checkbox', checkboxLabel: 'Sim, requer reinicialização do sistema' }
 ]
 },

 };

 /**
 * ============================================================================
 * UI OVERRIDES & CUSTOMIZATIONS
 * ============================================================================
 * Centraliza as customizações de UI que podem ser diferentes da configuração
 * padrão vinda do backend. Isso é útil para adaptar formulários e colunas
 * para necessidades específicas do frontend sem alterar o backend.
 *
 * Este conceito é similar à correção necessária no teste `UX.mainSheets.fullCRUD`,
 * onde cada planilha precisa de um conjunto de campos específico.
 */
 const UI_OVERRIDES = {
            'alunos': {
 // Exemplo: Se quiséssemos um formulário diferente do padrão
                // formUrl: 'Form-Alunos-Simplificado'
 },
            'veiculos': {
                // Exemplo: Se a coluna 'Placa' no backend se chama 'ID_Veiculo'
                // mas queremos mostrar 'Placa' na UI.
 columns: [
                    { label: 'Placa', field: 'Placa' },
                    { label: 'Modelo', field: 'Modelo' },
                    { label: 'Status', field: 'Status', render: (row) => `<span class="status-badge ${row.Status?.toLowerCase()}">${row.Status}</span>` }
 ]
 },
            'rotas': {
 // Exemplo: Adicionar um campo de ajuda específico do frontend
 // fields: [ ... campos com helpText customizado ... ]
 }
 };

 // ============================================================================
 // AUTO-INICIALIZAÇÃO
 // ============================================================================

 /**
 * Despachante de eventos 100% DATA-DRIVEN - Versão 3.0
 * Decide o que fazer quando uma seção é alterada consultando o SheetMappingManager
 */
 const sectionChangeDispatcher = async (e) => {
 const { section: sectionId } = e.detail;

 if (!window.SheetMappingManager || !window.CRUDManagerUniversal) {
                console.warn('[Dispatcher] Módulos essenciais (SheetMappingManager, CRUDManagerUniversal) não carregados.');
 return;
 }

 console.log(`[Dispatcher] 📍 Processando seção: ${sectionId}`);

 // 1. Verifica se a seção tem um handler customizado
 if (CUSTOM_SECTION_HANDLERS[sectionId]) {
 const handler = CUSTOM_SECTION_HANDLERS[sectionId];
                if (typeof handler === 'function') {
 console.log(`[Dispatcher] ⚙️ Executando handler customizado para: ${sectionId}`);
 const customContainer = document.querySelector(`#${sectionId}-section`);
 if (customContainer) {
 handler(customContainer);
 } else {
 console.error(`[Dispatcher] ❌ Container #${sectionId}-section não encontrado.`);
 }
 }
 return; // Handler customizado processado
 }

 // 2. Obtém metadados da seção do SheetMappingManager
 const metadata = SheetMappingManager.getSectionMetadata(sectionId);
 if (!metadata) {
 console.log(`[Dispatcher] ⚠️ Metadados não encontrados para: ${sectionId}`);
 return;
 }

 // 3. Verifica se a seção tem tabs (múltiplas planilhas)
 if (metadata.tabs && metadata.tabs.length > 1) {
 console.log(`[Dispatcher] 📑 Seção com ${metadata.tabs.length} tabs - TabManager cuidará da inicialização`);
 // O TabManager (em JS-TabManager.html) cuidará da renderização
 return;
 }

 // 4. Obtém configuração da tabela do backend
 const sheetName = metadata.sheetName || metadata.sheets[0];
 const tableConfig = SheetMappingManager.getTableConfig(sheetName);

 if (!tableConfig) {
                console.error(`[Dispatcher] ❌ Configuração de tabela não encontrada para '${sheetName}'`);
 return;
 }

 // 5. Verifica se há container CRUD
 const container = document.querySelector(`#${sectionId}-crud-container`);
 if (!container) {
 console.log(`[Dispatcher] ℹ️ Container CRUD não encontrado para ${sectionId} - pode ser seção customizada`);
 return;
 }

 // 6. Verifica se já foi inicializado
 if (CRUDManagerUniversal.instances[sectionId]) {
 console.log(`[Dispatcher] ✓ CRUD para ${sectionId} já inicializado`);
 return;
 }

 // 7. Inicializa CRUD com configuração do backend
 console.log(`[Dispatcher] 🚀 Inicializando CRUD data-driven para: ${sectionId}`);

 // Merge com overrides de UI se existirem
 const uiOverride = UI_OVERRIDES[sectionId] || {};

 CRUDManagerUniversal.init({
 sectionId: sectionId,
 sheetName: sheetName,
 title: metadata.displayName || tableConfig.title,
 searchPlaceholder: `Buscar em ${metadata.displayName}...`,
 columns: uiOverride.columns || tableConfig.columns,
 fields: uiOverride.fields || tableConfig.fields,
 formUrl: metadata.formUrl || uiOverride.formUrl,
 hasCustomUI: metadata.hasCustomUI || false
 });

 console.log(`[Dispatcher] ✅ ${sectionId} inicializado com sucesso`);
 };

        document.addEventListener('sectionChanged', sectionChangeDispatcher);
        console.log('[BusinessLogic] ✅ Despachante data-driven v3.0 configurado');

        console.log('[BusinessLogic] Lógica de negócios inicializada');
 });
})();
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-CRUD-Universal.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 UNIVERSAL CRUD MANAGER & FORM BUILDER
 ============================================================================ */

(function() {
    'use strict';

 // ============================================================================
 // FORM BUILDER - Construtor Dinâmico de Formulários
 // ============================================================================

 const FormBuilder = {
 /**
 * Constrói HTML de formulário a partir de configuração de campos
 * @param {Array} fields - Array de configuração de campos
 * @param {Object} initialData - Dados iniciais para popular formulário
 * @returns {string} HTML do formulário.
 */
 build(fields, initialData = {}) {
 return fields.map(field => {
                const value = initialData[field.name] || field.default || '';
 let fieldHtml = `
                    <div class="form-group">
                        <label class="form-label" for="form-${field.name}">
                            ${field.label}${field.required ? ' <span class="required">*</span>' : ''}
 </label>`;

 switch (field.type) {
                    case 'textarea':
 fieldHtml += `
 <textarea
                                id="form-${field.name}-1"
                                name="${field.name}"
                                class="form-control"
                                rows="${field.rows || 3}"
                                placeholder="${field.placeholder || ''}"
                                ${field.required ? 'required' : ''}
 >${value}</textarea>`;
 break;

                    case 'select':
 fieldHtml += `
 <select
                                id="form-${field.name}-1"
                                name="${field.name}"
                                class="form-control"
                                ${field.required ? 'required' : ''}
 >
                                <option value="">Selecione...</option>`;
 (field.options || []).forEach(opt => {
 const optValue = opt.value !== undefined ? opt.value : opt;
 const optLabel = opt.label !== undefined ? opt.label : opt;
 fieldHtml += `
                                <option value="${optValue}" ${value === optValue ? 'selected' : ''}>
 ${optLabel}
 </option>`;
 });
 fieldHtml += `</select>`;
 break;

                    case 'checkbox':
 fieldHtml += `
                            <div class="checkbox-wrapper">
 <input
                                    type="checkbox"
                                    id="form-${field.name}-1"
                                    name="${field.name}"
                                    value="true"
                                    ${value === true || value === 'true' ? 'checked' : ''}
 >
                                <label for="form-${field.name}">${field.checkboxLabel || field.label}</label>
 </div>`;
 break;

                    case 'date':
 fieldHtml += `
 <input
                                type="date"
                                id="form-${field.name}-1"
                                name="${field.name}"
                                class="form-control"
                                value="${value}"
                                ${field.required ? 'required' : ''}
 >`;
 break;

                    case 'number':
 fieldHtml += `
 <input
                                type="number"
                                id="form-${field.name}-1"
                                name="${field.name}"
                                class="form-control"
                                value="${value}"
                                min="${field.min !== undefined ? field.min : ''}"
                                max="${field.max !== undefined ? field.max : ''}"
                                step="${field.step || '1'}"
                                placeholder="${field.placeholder || ''}"
                                ${field.required ? 'required' : ''}
 >`;
 break;

                    case 'email':
 fieldHtml += `
 <input
                                type="email"
                                id="form-${field.name}-1"
                                name="${field.name}"
                                class="form-control"
                                value="${value}"
                                placeholder="${field.placeholder || ''}"
                                ${field.required ? 'required' : ''}
 >`;
 break;

                    case 'tel':
 fieldHtml += `
 <input
                                type="tel"
                                id="form-${field.name}-1"
                                name="${field.name}"
                                class="form-control"
                                value="${value}"
                                placeholder="${field.placeholder || ''}"
                                ${field.required ? 'required' : ''}
 >`;
 break;

 default: // text
 fieldHtml += `
 <input
                                type="text"
                                id="form-${field.name}-1"
                                name="${field.name}"
                                class="form-control"
                                value="${value}"
                                placeholder="${field.placeholder || ''}"
                                ${field.required ? 'required' : ''}
 >`;
 }

 if (field.helpText) {
                    fieldHtml += `<small class="form-help-text">${field.helpText}</small>`;
 }

 // Container for validation messages
                fieldHtml += `<div class="form-error-message" id="error-form-${field.name}"></div>`;

 fieldHtml += `</div>`;
 return fieldHtml;
            }).join('');
 },

 /**
 * Extrai dados do formulário
 * @param {string} formId - ID do formulário
 * @returns {Object} Dados do formulário.
 */
 getData(formId) {
 const form = document.getElementById(formId);
 if (!form) return {};

 const formData = new FormData(form);
 const data = {};

 for (let [key, value] of formData.entries()) {
 data[key] = value;
 }

            // Handle checkboxes that weren't checked
            form.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
 if (!data.hasOwnProperty(checkbox.name)) {
 data[checkbox.name] = false;
 }
 });

 return data;
 },

 /**
 * Valida formulário
 * @param {string} formId - ID do formulário.
 * @returns {{isValid: boolean, invalidFields: Array<Element>}} Objeto com status de validação e campos inválidos.
 */
 validate(formId) {
 const form = document.getElementById(formId);
 if (!form) return { isValid: false, invalidFields: [] };

 const invalidFields = [];
 let firstInvalidField = null;

 // Limpa erros anteriores
            form.querySelectorAll('.form-control').forEach(el => {
                el.classList.remove('is-invalid');
 const errorContainer = document.getElementById(`error-${el.id}`);
                if (errorContainer) errorContainer.textContent = '';
 });

 // Verifica a validade de cada campo
 for (const el of form.elements) {
 if (el.willValidate && !el.checkValidity()) {
 invalidFields.push(el);
                    el.classList.add('is-invalid');

 const errorContainer = document.getElementById(`error-${el.id}`);
 if (errorContainer) {
 errorContainer.textContent = el.validationMessage;
 }

 if (!firstInvalidField) {
 firstInvalidField = el;
 }
 }
 }

 // Foca no primeiro campo inválido
 if (firstInvalidField) {
 firstInvalidField.focus();
 }

 return { isValid: invalidFields.length === 0, invalidFields };
 }
 };

 window.FormBuilder = FormBuilder;

 // ============================================================================
 // MODAL MANAGER - Gerenciador de Modais
 // ============================================================================

 const ModalManager = {
 modals: new Map(),

 /**
 * Cria um modal
 * @param {string} modalId - ID único do modal
 * @param {Object} config - Configuração (title, content, footer)
 */
 create(modalId, config) {
 // Remove modal existente se houver
 this.destroy(modalId);

            const modal = document.createElement('div');
 modal.id = modalId;
            modal.className = 'modal';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.setAttribute('aria-labelledby', `${modalId}-title`);

 modal.innerHTML = `
                <div class="modal-dialog">
                    <div class="modal-header">
                        <h3 class="modal-title" id="${modalId}-title">${config.title || 'Modal'}</h3>
                        <button class="btn-icon" onclick="ModalManager.close('${modalId}')" aria-label="Fechar">
                            <i class="fas fa-times"></i>
 </button>
 </div>
                    <div class="modal-body">
                        ${config.content || ''}
 </div>
                    ${config.footer ? `<div class="modal-footer">${config.footer}</div>` : ''}
 </div>
 `;

 document.body.appendChild(modal);
 this.modals.set(modalId, modal);

 // Close on backdrop click
            modal.addEventListener('click', (e) => {
 if (e.target === modal) {
 this.close(modalId);
 }
 });

 // Close on ESC key
 const escHandler = (e) => {
                if (e.key === 'Escape') {
 this.close(modalId);
 }
 };
 modal.escHandler = escHandler;
            document.addEventListener('keydown', escHandler);
 },

 /**
 * Abre um modal
 */
 open(modalId) {
 const modal = this.modals.get(modalId) || document.getElementById(modalId);
 if (!modal) return;

            modal.classList.add('active');
            modal.setAttribute('aria-hidden', 'false');

 // Focus first focusable element
            const firstFocusable = modal.querySelector('input, select, textarea, button');
 if (firstFocusable) {
 setTimeout(() => firstFocusable.focus(), 100);
 }
 },

 /**
 * Fecha um modal
 */
 close(modalId) {
 const modal = this.modals.get(modalId) || document.getElementById(modalId);
 if (!modal) return;

            modal.classList.remove('active');
            modal.setAttribute('aria-hidden', 'true');
 },

 /**
 * Destrói um modal
 */
 destroy(modalId) {
 const modal = this.modals.get(modalId) || document.getElementById(modalId);
 if (!modal) return;

 if (modal.escHandler) {
                document.removeEventListener('keydown', modal.escHandler);
 }

 modal.remove();
 this.modals.delete(modalId);
 }
 };

 window.ModalManager = ModalManager;

 // ============================================================================
 // UNIVERSAL CRUD MANAGER
 // ============================================================================

 window.CRUDManagerUniversal = {
 instances: {},
 customFormHandlers: {}, // Registro de handlers para formulários customizados

 /**
 * Registra um handler para formulário customizado
 * @param {string} sectionId - ID da seção
 * @param {Object} handler - Objeto com funções open, submit, validate
 */
 registerCustomForm(sectionId, handler) {
 this.customFormHandlers[sectionId] = handler;
 console.log(`[CRUD] Formulário customizado registrado para: ${sectionId}`);
 },

 /**
 * Verifica se uma seção tem formulário customizado
 */
 hasCustomForm(sectionId) {
 return this.customFormHandlers.hasOwnProperty(sectionId);
 },

 /**
 * Inicializa sistema CRUD para uma seção
 * @param {Object} config - Configuração completa
 */
 init(config) {
 const { sectionId, sheetName, title, columns, fields, searchPlaceholder, subtitle, icon, hasCustomUI } = config;

 if (this.instances[sectionId]) {
 console.log(`[CRUD] Seção ${sectionId} já inicializada`);
 return;
 }

 const instance = {
 subtitle,
 icon,
 sectionId,
 sheetName,
 title,
 columns,
 fields,
 data: [],
                searchQuery: '',
                sortColumn: columns[0]?.field || 'ID',
                sortDirection: 'asc',
 currentPage: 1,
 itemsPerPage: 10,
 hasCustomUI: hasCustomUI || false // Marca se tem UI customizada
 };
 this.instances[sectionId] = instance;

 const container = document.getElementById(`${sectionId}-crud-container`);
 if (!container) {
 console.warn(`[CRUD] Container não encontrado: ${sectionId}-crud-container`);
 return;
 }

 // Renderiza UI do CRUD
 container.innerHTML = `
                <div class="page-header section-header-standardized">
                    <h2 class="page-title section-title-standardized"><i class="fas ${icon || 'fa-cogs'}"></i> ${title}</h2>
                    ${subtitle ? `<p class="page-subtitle">${subtitle}</p>` : ''}
 </div>
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-list"></i> Lista de Registros</h3>
                        <div class="crud-actions">
 <input
                                type="search"
                                class="form-control"
                                placeholder="${searchPlaceholder || 'Buscar...'}"
                                id="${sectionId}-search-input"
                                oninput="CRUDManagerUniversal.debouncedSearchHandler('${sectionId}', this.value)"
 >
                            <button class="btn btn-primary" onclick="CRUDManagerUniversal.openCreateModal('${sectionId}')">
                                <i class="fas fa-plus"></i> Novo
 </button>
 </div>
 </div>
                    <div class="card-body">
                        <div class="data-table-container" id="${sectionId}-table-container"></div>
 </div>
                    <div class="card-footer">
                        <div id="${sectionId}-pagination-container" class="pagination-container"></div>
 </div>
 </div>`;

 this.loadData(sectionId);
 },

 /**
 * Carrega dados da API
 */
 async loadData(sectionId) {
 const instance = this.instances[sectionId];
 if (!instance) return;

            LoadingManager.show('Carregando dados...');
 try {
                const response = await API.run('readRecords', { sheetName: instance.sheetName });
 instance.data = Array.isArray(response) ? response : [];
 this.renderTable(sectionId);
 } catch (error) {
 console.error(`[CRUD] Erro ao carregar dados de ${sectionId}:`, error);
                ToastManager.show(`Falha ao carregar dados para ${instance.title}. Detalhe: ${error.message}`, 'error');
 } finally {
 LoadingManager.hide();
 }
 },

 /**
 * Renderiza tabela
 */
 renderTable(sectionId) {
 const instance = this.instances[sectionId];
 if (!instance) {
 console.warn(`[renderTable] Instância não encontrada para ${sectionId}`);
 return;
 }

 let filteredData = instance.data;

 // Aplica filtro de busca
 if (instance.searchQuery) {
 const query = instance.searchQuery.toLowerCase();
 filteredData = instance.data.filter(row => {
 return JSON.stringify(row).toLowerCase().includes(query);
 });
 }

 // Aplica ordenação
 if (instance.sortColumn) {
 filteredData.sort((a, b) => {
 const valA = a[instance.sortColumn];
 const valB = b[instance.sortColumn];

 if (valA < valB) {
                        return instance.sortDirection === 'asc' ? -1 : 1;
 }
 if (valA > valB) {
                        return instance.sortDirection === 'asc' ? 1 : -1;
 }
 return 0;
 });
 }

 // Aplica paginação
 const totalItems = filteredData.length;
 const totalPages = Math.ceil(totalItems / instance.itemsPerPage);
 instance.currentPage = Math.max(1, Math.min(instance.currentPage, totalPages)); // Garante que a página atual é válida

 const startIndex = (instance.currentPage - 1) * instance.itemsPerPage;
 const endIndex = startIndex + instance.itemsPerPage;
 const paginatedData = filteredData.slice(startIndex, endIndex);

 const columnsWithActions = [
 ...instance.columns,
 {
                    label: 'Ações',
 render: (row) => `
                        <div class="table-actions">
                            <button aria-label="Editar" class="btn-icon btn-sm" title="Editar" onclick='CRUDManagerUniversal.openEditModal("${sectionId}", ${JSON.stringify(row).replace(/'/g, "&apos;")})'>
                                <i class="fas fa-pencil-alt"></i>
 </button>
                            <button aria-label="Excluir" class="btn-icon btn-sm btn-error" title="Excluir" onclick='CRUDManagerUniversal.confirmDelete("${sectionId}", "${row.ID || row.id}")'>
                                <i class="fas fa-trash"></i>
 </button>
 </div>`
 }
 ];

 TableRenderer.render(`${sectionId}-table-container`, paginatedData, columnsWithActions, {
 emptyMessage: `Nenhum registro de ${instance.title.toLowerCase()} encontrado.`,
 sectionId: sectionId,
 sortState: { column: instance.sortColumn, direction: instance.sortDirection }
 });

 this.renderPaginationControls(sectionId, totalPages, totalItems);
 },

 /**
 * Lida com a busca (chamada diretamente pelo debouncer)
 */
 handleSearch(sectionId, query) {
 const instance = this.instances[sectionId];
 if (!instance) return;

 instance.searchQuery = query;
 instance.currentPage = 1; // Reseta para a primeira página ao buscar
 this.renderTable(sectionId);
 },

 /**
 * Handler de busca com debounce para o evento oninput.
 * Usa o Utils.debounce para evitar chamadas excessivas.
 */
 debouncedSearchHandler: Utils.debounce(function(sectionId, query) {
            // O 'this' aqui dentro será o CRUDManagerUniversal por causa do debounce
 this.handleSearch(sectionId, query);
 }, 300),

 /**
 * Lida com a ordenação da tabela
 */
 handleSort(sectionId, field) {
 const instance = this.instances[sectionId];
 if (!instance) return;

 if (instance.sortColumn === field) {
                instance.sortDirection = instance.sortDirection === 'asc' ? 'desc' : 'asc';
 } else {
 instance.sortColumn = field;
                instance.sortDirection = 'asc';
 }
 this.renderTable(sectionId);
 },

 /**
 * Lida com mudanças de página
 */
 handlePageChange(sectionId, newPage) {
     const instance = this.instances[sectionId];
     if (!instance) return;
     
     instance.currentPage = newPage;
     this.renderTable(sectionId);
 },

 /**
 * Renderiza os controles de paginação
 */
 renderPaginationControls(sectionId, totalPages, totalItems) {
 const instance = this.instances[sectionId];
 const container = document.getElementById(`${sectionId}-pagination-container`);
 if (!container || totalPages <= 1) {
                if(container) container.innerHTML = '';
 return;
 }

 const currentPage = instance.currentPage;

 let paginationHtml = `
                <div class="pagination-info">
 Página ${currentPage} de ${totalPages} (${totalItems} registros)
 </div>
                <div class="pagination-buttons">
 <button
                        class="btn btn-sm btn-secondary"
                        onclick="CRUDManagerUniversal.handlePageChange('${sectionId}', ${currentPage - 1})"
                        ${currentPage === 1 ? 'disabled' : ''}>
                        <i class="fas fa-chevron-left"></i> Anterior
 </button>
 `;

 // Lógica para mostrar números de página (simplificada)
 for (let i = 1; i <= totalPages; i++) {
 if (i === currentPage) {
                    paginationHtml += `<button class="btn btn-sm btn-primary" disabled>${i}</button>`;
 } else {
                    paginationHtml += `<button class="btn btn-sm btn-secondary" onclick="CRUDManagerUniversal.handlePageChange('${sectionId}', ${i})">${i}</button>`;
 }
 }

 paginationHtml += `
 <button
                        class="btn btn-sm btn-secondary"
                        onclick="CRUDManagerUniversal.handlePageChange('${sectionId}', ${currentPage + 1})"
                        ${currentPage === totalPages ? 'disabled' : ''}>
                        Próxima <i class="fas fa-chevron-right"></i>
 </button>
 </div>
 `;

 container.innerHTML = paginationHtml;
 },

 /**
 * Abre modal de criação
 */
 async openCreateModal(sectionId) {
 this.openFormModal(sectionId);
 },

 /**
 * Abre modal de edição
 */
 openEditModal(sectionId, rowData) {
 this.openFormModal(sectionId, rowData);
 },

 /**
 * Função unificada para abrir modal de formulário (criação ou edição)
 */
 async openFormModal(sectionId, initialData = null) {
 const instance = this.instances[sectionId];
 if (!instance) return;

 const isEditMode = initialData !== null;
             const modalId = `${isEditMode ? 'edit' : 'create'}-${sectionId}-modal`;
 const formId = `form-${sectionId}`;
             const title = `${isEditMode ? 'Editar' : 'Novo'} ${instance.title}`;

 // Verifica se existe handler customizado para formulários (mantido para compatibilidade)
 if (this.hasCustomForm(sectionId)) {
 const handler = this.customFormHandlers[sectionId];
 if (isEditMode && handler.openEdit) {
 handler.openEdit(initialData.ID || initialData.id);
 return;
 }
 if (!isEditMode && handler.openCreate) {
 handler.openCreate();
 return;
 }
 }

        let formContent = '';
        
        // Se houver formUrl, carrega o HTML customizado dinamicamente
        if (instance.formUrl) {
            LoadingManager.show('Carregando formulário...');
            try {
                const response = await fetch(`?file=${instance.formUrl}`);
                if (!response.ok) throw new Error(`Erro ao carregar formulário: ${response.status}`);
                
                let customHtml = await response.text();
                
                // Extrai apenas o conteúdo do form (remove wrappers desnecessários)
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = customHtml;
                const formElement = tempDiv.querySelector('form');
                
                if (formElement) {
                    // Garante que o form tenha o ID correto
                    formElement.id = formId;
                    formContent = formElement.outerHTML;
                } else {
                    // Se não houver um <form>, usa o HTML completo
                    formContent = `<form id="${formId}">${customHtml}</form>`;
                }
                
                // Se estiver em modo edição, vai preencher os campos após abrir o modal
                if (isEditMode) {
                    instance._pendingEditData = initialData;
                }
            } catch (error) {
                console.error('[CRUD] Erro ao carregar formulário customizado:', error);
                ToastManager.show('Erro ao carregar formulário. Usando formulário padrão.', 'error');
                // Fallback para FormBuilder se houver fields configurados
                if (instance.fields) {
                    formContent = FormBuilder.build(instance.fields, initialData || {});
                } else {
                    ToastManager.show('Formulário não configurado corretamente.', 'error');
                    LoadingManager.hide();
                    return;
                }
            } finally {
                LoadingManager.hide();
            }
        } else if (instance.fields) {
            // Se não houver formUrl, usa FormBuilder como antes
            formContent = FormBuilder.build(instance.fields, initialData || {});
        } else {
            console.error('[CRUD] Nem formUrl nem fields estão definidos para:', sectionId);
            ToastManager.show('Configuração de formulário ausente.', 'error');
            return;
        }

 const footer = `
                 <button class="btn btn-secondary" onclick="ModalManager.close('${modalId}')">Cancelar</button>
                 <button class="btn btn-primary" onclick="CRUDManagerUniversal.handleFormSubmit('${sectionId}', '${formId}', ${isEditMode ? `'${initialData.ID || initialData.id}'` : 'null'})">
                     <i class="fas fa-save"></i> ${isEditMode ? 'Atualizar' : 'Salvar'}
 </button>
 `;

 ModalManager.create(modalId, {
 title: title,
                 content: formContent,
 footer: footer
 });

 ModalManager.open(modalId);
        
        // Se houver dados pendentes para edição, preenche os campos
        if (instance._pendingEditData) {
            setTimeout(() => {
                this.populateCustomForm(formId, instance._pendingEditData);
                delete instance._pendingEditData;
            }, 100);
        }
 },

 /**
 * Submete criação
 */
 async submitCreate(sectionId) {
 const instance = this.instances[sectionId];
 if (!instance) return;

 const formData = FormBuilder.getData(`form-create-${sectionId}`);

 const validationResult = FormBuilder.validate(`form-create-${sectionId}`);
 if (!validationResult.isValid) {
                ToastManager.show('Por favor, corrija os campos destacados.', 'warning');
 return;
 }

            LoadingManager.show('Salvando...');
 try {
                await API.run('createRecord', { sheetName: instance.sheetName, data: formData });
                ToastManager.show('Registro criado com sucesso!', 'success');
 ModalManager.close(`create-${sectionId}`);
 this.loadData(sectionId);
 } catch (error) {
 console.error(`[CRUD] Erro em submitCreate para ${sectionId}:`, error);
                ToastManager.show(`Falha ao criar registro. Detalhe: ${error.message}`, 'error');
 } finally {
 LoadingManager.hide();
 }
 },

 /**
 * Submete edição
 */
 async handleFormSubmit(sectionId, formId, recordId = null) {
 const instance = this.instances[sectionId];
 const formData = FormBuilder.getData(formId);
 const validationResult = FormBuilder.validate(formId);
 if (!validationResult.isValid) {
                ToastManager.show('Por favor, corrija os campos destacados.', 'warning');
 return;
 }

            LoadingManager.show('Atualizando...');
 try {
 if (recordId) {
                    await API.run('updateRecord', { sheetName: instance.sheetName, id: recordId, data: formData });
                    ToastManager.show('Registro atualizado com sucesso!', 'success');
 } else {
                    await API.run('createRecord', { sheetName: instance.sheetName, data: formData });
                    ToastManager.show('Registro criado com sucesso!', 'success');
 }

                ModalManager.close(`${recordId ? 'edit' : 'create'}-${sectionId}-modal`);
 this.loadData(sectionId);
 } catch (error) {
 console.error(`[CRUD] Erro em handleFormSubmit para ${sectionId}:`, error);
                ToastManager.show(`Falha ao atualizar registro. Detalhe: ${error.message}`, 'error');
 } finally {
 LoadingManager.hide();
 }
 },

 /**
 * Popula formulário customizado com dados para edição
 */
 populateCustomForm(formId, data) {
     const form = document.getElementById(formId);
     if (!form || !data) return;

     Object.keys(data).forEach(key => {
         // Procura campo pelo atributo name
         let field = form.querySelector(`[name="${key}"]`);
         
         // Se não encontrar, tenta com nomes transformados (ex: Nome_Completo -> nome_completo)
         if (!field) {
             const lowerKey = key.toLowerCase();
             field = form.querySelector(`[name="${lowerKey}"]`);
         }
         
         if (field) {
             if (field.type === 'checkbox') {
                 field.checked = data[key] === true || data[key] === 'true' || data[key] === 'Sim';
             } else if (field.type === 'radio') {
                 const radio = form.querySelector(`[name="${key}"][value="${data[key]}"]`);
                 if (radio) radio.checked = true;
             } else {
                 field.value = data[key] || '';
             }
         }
     });

     // Marca o formulário como em modo edição
     form.dataset.editingId = data.ID || data.id;
     
     console.log('[CRUD] Formulário customizado populado com dados:', data);
 },

 /**
 * Confirma exclusão
 */
 async confirmDelete(sectionId, recordId) {
            if (!confirm('Tem certeza que deseja excluir este registro?')) return;

 const instance = this.instances[sectionId];
 if (!instance) return;

            LoadingManager.show('Excluindo...');
 try {
                await API.run('deleteRecord', { sheetName: instance.sheetName, id: recordId });
                ToastManager.show('Registro excluído com sucesso!', 'success');
 this.loadData(sectionId);
 } catch (error) {
 console.error(`[CRUD] Erro em confirmDelete para ${sectionId}:`, error);
                ToastManager.show(`Falha ao excluir registro. Detalhe: ${error.message}`, 'error');
 } finally {
 LoadingManager.hide();
 }
 }
 };

    console.log('[CRUD Universal] Sistema CRUD Universal inicializado');
})();
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-CascadingLogic.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 CASCADING LOGIC & BUSINESS RULES
 ============================================================================
 Versão: 2.0 (Refatorado por Gemini Code Assist)
 Implementa regras de negócio complexas:
 - Acompanhantes ocupam 2 assentos
 - Cascateamento entre Rotas → Alunos → Frequência
 - Substituído MutationObserver por um sistema de eventos para desacoplamento.
 - Controle de vagas em veículos
 - Validações de capacidade
 ============================================================================ */

(function() {
    'use strict';

 /**
 * Gerenciador de Regras de Negócio e Cascateamento
 */
 const BusinessRulesManager = {
 VEHICLE_CAPACITY_CACHE: {},

 // ========================================================================
 // ACOMPANHANTES - LÓGICA DE 2 ASSENTOS
 // ========================================================================

 /**
 * Verifica se um passageiro necessita de acompanhante (ocupa 2 assentos).
 * @param {Object} passenger - O objeto do passageiro.
 * @returns {boolean}
 */
 isCompanion(passenger) {
 if (!passenger) return false;
            return passenger.Tipo === 'Acompanhante' ||
                   passenger.Acompanhante === 'Sim' ||
                   passenger.Necessita_Acompanhante === 'Sim';
 },

 /**
 * Calcula ocupação real de assentos considerando acompanhantes
 * @param {Array} passengers - Lista de passageiros
 * @returns {number} Total de assentos ocupados
 */
 calculateSeatsOccupied(passengers) {
 if (!passengers || !Array.isArray(passengers)) return 0;
 return passengers.reduce((total, passenger) => {
 // Acompanhante = 2 assentos, Aluno normal = 1 assento
 return total + (this.isCompanion(passenger) ? 2 : 1);
 }, 0);
 },

 /**
 * Valida se há vagas suficientes no veículo
 * @param {string} vehicleId - ID do veículo
 * @param {Array} currentPassengers - Lista atual de passageiros
 * @param {Object} newPassenger - Novo passageiro a adicionar
 * @returns {Promise<Object>} {valid: boolean, message: string, available: number}
 */
 async validateVehicleCapacity(vehicleId, currentPassengers, newPassenger = null) {
 try {
 // Usa cache para dados do veículo para evitar chamadas repetidas
 if (!this.VEHICLE_CAPACITY_CACHE[vehicleId]) {
                    const vehicles = await API.run('readRecords', {
                        sheetName: 'Veiculos',
 filters: { ID: vehicleId }
 });
 if (!vehicles || vehicles.length === 0) {
                        return { valid: false, message: 'Veículo não encontrado', available: 0 };
 }
 this.VEHICLE_CAPACITY_CACHE[vehicleId] = vehicles[0];
 }

 const vehicle = this.VEHICLE_CAPACITY_CACHE[vehicleId];
 const totalCapacity = parseInt(vehicle.Capacidade || 0);

 // Busca dados do veículo

 // Calcula ocupação atual
 const currentOccupation = this.calculateSeatsOccupied(currentPassengers);

 // Calcula quanto o novo passageiro vai ocupar
 const newSeats = newPassenger ? (this.isCompanion(newPassenger) ? 2 : 1) : 0;

 const availableSeats = totalCapacity - currentOccupation;
 const valid = availableSeats >= newSeats;
 const isNewCompanion = this.isCompanion(newPassenger);
 return {
 valid,
 message: valid ?
 `Vagas disponíveis: ${availableSeats} de ${totalCapacity}` :
                        `Sem vagas suficientes. ${isNewCompanion ? 'Acompanhante precisa de 2 assentos' : 'Precisa de 1 assento'}, disponível: ${availableSeats}`,
 available: availableSeats,
 required: newSeats,
 capacity: totalCapacity,
 occupied: currentOccupation
 };

 } catch (error) {
                console.error('[BusinessRules] Erro ao validar capacidade do veículo:', error);
 return {
 valid: false,
                    message: 'Erro ao verificar capacidade do veículo',
 available: 0
 };
 }
 },

 async validateAndDisplayCapacity(vehicleId, passengers) {
 const validation = await this.validateVehicleCapacity(vehicleId, passengers);
            const container = document.querySelector('#frequencia-section .card-body');
 if (!container) return;

            let capacityBadge = container.querySelector('.capacity-info-badge');
 if (!capacityBadge) {
                capacityBadge = document.createElement('div');
                capacityBadge.className = 'capacity-info-badge';
 container.insertBefore(capacityBadge, container.firstChild);
 }

 const occupiedSeats = validation.occupied;
 const percentage = validation.capacity > 0 ? (occupiedSeats / validation.capacity) * 100 : 0;
            const statusClass = percentage > 100 ? 'error' : percentage > 90 ? 'warning' : 'success';

 capacityBadge.innerHTML = `
                <div class="alert alert-${statusClass} mb-4" >
                    <strong><i class="fas fa-bus"></i> Capacidade do Veículo:</strong>
                    <div  class="flex gap-3 items-center" style="margin-top: var(--space-2)">
 <span>Total: ${validation.capacity} assentos</span> •
 <span>Ocupados: ${occupiedSeats}</span> •
                        <span  class="font-semibold">Disponíveis: ${validation.available}</span>
 </div>
                    ${percentage > 100 ? '<p  class="font-bold" style="margin-top: var(--space-2)">⚠️ ATENÇÃO: Rota com mais alunos que a capacidade do veículo!</p>' : ''}
 </div>`;

 // DISPATCH: evento público para que o Menu atualize badges em tempo real
 try {
                const capacityEvent = new CustomEvent('capacityUpdated', {
 detail: { vehicleId, capacity: validation.capacity, occupied: occupiedSeats, available: validation.available, percentage }
 });
 document.dispatchEvent(capacityEvent);
 } catch (err) {
                Logger.warn('[BusinessRules] Falha ao disparar capacityUpdated', err);
 }
 },

 /**
 * Adiciona campo de acompanhante dinamicamente em formulários de alunos
 */
 enhanceStudentForm() {
            document.addEventListener('formRendered', (e) => {
 const { form, sectionId } = e.detail;
                if (sectionId !== 'alunos') return;

                const necessidadesField = form.querySelector('[name="necessidades_especiais"]');
                if (!necessidadesField || form.querySelector('[name="necessita_acompanhante"]')) return;

                const formGroup = necessidadesField.closest('.form-group');
 if (formGroup) {
                    const companionField = document.createElement('div');
                    companionField.className = 'form-group';
 companionField.innerHTML = `
                        <label class="form-label" for="form-necessita_acompanhante">
                            Necessita Acompanhante <i class="fas fa-info-circle" data-tooltip="Acompanhante ocupará 2 assentos no veículo"></i>
 </label>
                        <select id="form-necessita_acompanhante" name="necessita_acompanhante" class="form-control">
                            <option value="Não">Não</option>
                            <option value="Sim">Sim (ocupará 2 assentos)</option>
 </select>
                        <small class="form-help-text"  style="color: var(--md-sys-color-warning)">
 ⚠️ Acompanhante ocupa 2 assentos no transporte
 </small>
 `;
                    formGroup.insertAdjacentElement('afterend', companionField);
                    Logger.info('[BusinessRules] Campo de acompanhante adicionado dinamicamente.');
 }
 });
 },

 // ========================================================================
 // CASCATEAMENTO ROTAS → ALUNOS
 // ========================================================================

 /**
 * Carrega alunos associados a uma rota
 * @param {string} routeId - ID da rota
 * @returns {Promise<Array>} Lista de alunos
 */
 async getStudentsByRoute(routeId) {
 if (!routeId) return [];

 try {
                LoadingManager.show('Carregando alunos da rota...');

                const students = await API.run('readRecords', {
                    sheetName: 'Alunos',
 filters: {
 Rota_ID: routeId,
                        Status_Ativo: 'Ativo'
 }
 });

 Logger.info(`[Cascading] Rota ${routeId}: ${students.length} alunos encontrados`);
 return students || [];

 } catch (error) {
                console.error('[Cascading] Erro ao carregar alunos:', error);
                ToastManager.show('Erro ao carregar alunos da rota', 'error');
 return [];
 } finally {
 LoadingManager.hide();
 }
 },

 /**
 * Atualiza seletores dependentes quando rota é alterada
 * @param {string} routeId - ID da rota selecionada
 * @param {string} targetSelectId - ID do select de destino
 */
        async cascadeRouteToStudents(routeId, targetSelectId = 'aluno-select') {
 const select = document.getElementById(targetSelectId);
 if (!select) {
 Logger.warn(`[Cascading] Select ${targetSelectId} não encontrado`);
 return;
 }

 // Limpa opções
            select.innerHTML = '<option value="">Carregando...</option>';
 select.disabled = true;

 if (!routeId) {
                select.innerHTML = '<option value="">Selecione uma rota primeiro</option>';
 return;
 }

 try {
 const students = await this.getStudentsByRoute(routeId);

 if (students.length === 0) {
                    select.innerHTML = '<option value="">Nenhum aluno ativo nesta rota</option>';
                    ToastManager.show('Rota sem alunos ativos', 'warning');
 return;
 }

 // Popula select com alunos
                select.innerHTML = '<option value="">Selecione um aluno...</option>';
 students.forEach(student => {
                    const option = document.createElement('option');
 option.value = student.ID;

 // Indica se tem acompanhante (usando a regra de negócio)
                    const hasCompanion = student.Necessita_Acompanhante === 'Sim';
                    const companionIcon = hasCompanion ? ' 👥 (2 assentos)' : '';

 option.textContent = `${student.Nome_Completo}${companionIcon} - ${student.Escola}`;
 option.dataset.hasCompanion = hasCompanion;
 option.dataset.school = student.Escola;

 select.appendChild(option);
 });

 select.disabled = false;
                ToastManager.show(`${students.length} aluno(s) carregado(s)`, 'success', 1500);

 } catch (error) {
                select.innerHTML = '<option value="">Erro ao carregar alunos</option>';
                console.error('[Cascading] Erro:', error);
 }
 },

 /**
 * Configura cascateamento automático em formulários
 */
 setupCascadingListeners() {
            // Ouve o evento 'formRendered' disparado pelo CRUDManager ou outros componentes
            document.addEventListener('formRendered', (e) => {
 const { form } = e.detail;
                const routeSelect = form.querySelector('[data-cascade-source="route"]');
                const studentSelect = form.querySelector('[data-cascade-target="student"]');

 if (!routeSelect || !studentSelect) return;

                Logger.info('[Cascading] Listener de cascateamento configurado para o formulário.', { formId: form.id });

                routeSelect.addEventListener('change', () => {
 this.cascadeRouteToStudents(routeSelect.value, studentSelect.id);
 });
 });
 },

 // ========================================================================
 // FREQUÊNCIA - INTEGRAÇÃO COMPLETA
 // ========================================================================

 /**
 * Enhances attendance manager with capacity validation
 */
 enhanceAttendanceManager() {
 // Ouve o evento disparado pelo AttendanceManager após carregar os alunos
            document.addEventListener('attendanceListLoaded', (e) => {
 const { students, vehicleId } = e.detail;
 if (vehicleId && students) {
                    Logger.info('[BusinessRules] Evento attendanceListLoaded capturado. Validando capacidade.', { vehicleId });
 this.validateAndDisplayCapacity(vehicleId, students); // A validação agora é feita aqui
 }
 });
 },

 // ========================================================================
 // INICIALIZAÇÃO
 // ========================================================================

 init() {
            Logger.info('[BusinessRules] Inicializando regras de negócio...');

 this.enhanceStudentForm();
 this.setupCascadingListeners();
 this.enhanceAttendanceManager();

            Logger.info('[BusinessRules] ✅ Regras de negócio ativadas');
 },

 };

 // Expor para o escopo global
 window.BusinessRulesManager = BusinessRulesManager;

    document.addEventListener('DOMContentLoaded', () => BusinessRulesManager.init());

})();
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-Components.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 UI COMPONENTS - Tooltips, Search, Chatbot, Tables, etc.
 SIG-TE - Sistema de Transporte Escolar do DF
 ============================================================================
 Versão: 2.0 (Refatorado por Gemini Code Assist)
 ============================================================================ */

(function() {
    'use strict';

    document.addEventListener('DOMContentLoaded', () => {

 // ============================================================================
 // TOOLTIP MANAGER
 // ============================================================================

 const TooltipManager = {
 tooltipEl: null,
 hideTimeout: null,
 prefersReducedMotion: false,

 init() {
                this.prefersReducedMotion = window.matchMedia?.('(prefers-reduced-motion: reduce)').matches;

                this.tooltipEl = document.createElement('div');
                this.tooltipEl.className = 'tooltip-bubble';
                this.tooltipEl.id = 'tooltip-bubble';
                this.tooltipEl.setAttribute('role', 'tooltip');
                this.tooltipEl.setAttribute('aria-hidden', 'true');
 document.body.appendChild(this.tooltipEl);

 // Use event delegation for performance
                document.body.addEventListener('mouseover', this.handleMouseOver.bind(this));
                document.body.addEventListener('mouseout', this.handleMouseOut.bind(this));
                document.body.addEventListener('focusin', this.handleFocusIn.bind(this));
                document.body.addEventListener('focusout', this.handleFocusOut.bind(this));

                console.log('[TooltipManager] Event delegation initialized.');
 },

 handleMouseOver(e) {
                const target = e.target.closest('[data-tooltip]');
 if (target) this.show(target);
 },

 handleMouseOut(e) {
                const target = e.target.closest('[data-tooltip]');
 if (target) this.hide(target);
 },

 handleFocusIn(e) {
                const target = e.target.closest('[data-tooltip]');
 if (target) this.show(target);
 },

 handleFocusOut(e) {
                const target = e.target.closest('[data-tooltip]');
 if (target) this.hide(target);
 },

 show(target) {
 clearTimeout(this.hideTimeout);
                const text = target.getAttribute('data-tooltip');
 if (!text) return;

 this.tooltipEl.textContent = text;
                this.tooltipEl.classList.add('show');
                this.tooltipEl.setAttribute('aria-hidden', 'false');

 const targetRect = target.getBoundingClientRect();
 const tooltipRect = this.tooltipEl.getBoundingClientRect();
 const padding = 10;

 let top = window.scrollY + targetRect.top - tooltipRect.height - padding;
 let left = window.scrollX + targetRect.left + (targetRect.width - tooltipRect.width) / 2;

 // Keep within viewport
 left = Math.max(window.scrollX + padding, Math.min(left, window.scrollX + window.innerWidth - tooltipRect.width - padding));
 if (top < window.scrollY + padding) {
 top = window.scrollY + targetRect.bottom + padding;
                    this.tooltipEl.classList.add('below');
 } else {
                    this.tooltipEl.classList.remove('below');
 }

 this.tooltipEl.style.top = `${top}px`;
 this.tooltipEl.style.left = `${left}px`;

                const id = 'tt-' + Math.random().toString(36).slice(2, 8);
 this.tooltipEl.id = id;
                target.setAttribute('aria-describedby', id);
 },

 hide(target) {
 this.hideTimeout = setTimeout(() => {
                    this.tooltipEl.classList.remove('show');
                    this.tooltipEl.setAttribute('aria-hidden', 'true');
                    target.removeAttribute('aria-describedby');
 }, 80);
 }
 };
 TooltipManager.init();

 // ============================================================================
 // SEARCH MANAGER
 // ============================================================================

 window.performSearch = function() {
            const searchInput = document.getElementById('global-search-input');
            const resultsContainer = document.getElementById('search-results');

 if (!searchInput || !resultsContainer) return;

 const query = searchInput.value.trim();

 if (!query) {
 resultsContainer.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-search empty-state-icon" aria-hidden="true"></i>
                        <p class="empty-state-text">Digite para buscar</p>
                        <p class="empty-state-subtext">Encontre alunos, veículos, rotas e mais</p>
 </div>
 `;
 return;
 }

            LoadingManager.show('Buscando...');

        // Busca real em múltiplas planilhas
        (async () => {
            try {
                const lowerQuery = query.toLowerCase();
                const allResults = [];

                // Buscar em paralelo em múltiplas planilhas
                if (window.DataLoader) {
                    const [alunos, veiculos, rotas] = await Promise.all([
                        DataLoader.load('Alunos', {}, false).catch(() => []),
                        DataLoader.load('Veiculos', {}, false).catch(() => []),
                        DataLoader.load('Rotas', {}, false).catch(() => [])
                    ]);

                    // Processar Alunos
                    alunos.forEach(a => {
                        if (a.Nome_Completo?.toLowerCase().includes(lowerQuery) || 
                            a.RA?.toLowerCase().includes(lowerQuery)) {
                            allResults.push({
                                type: 'Aluno',
                                name: a.Nome_Completo || 'Sem nome',
                                info: `${a.Escola || ''} - Rota ${a.Rota_ID || 'N/A'}`
                            });
                        }
                    });

                    // Processar Veículos
                    veiculos.forEach(v => {
                        if (v.Placa?.toLowerCase().includes(lowerQuery) || 
                            v.Modelo?.toLowerCase().includes(lowerQuery)) {
                            allResults.push({
                                type: 'Veículo',
                                name: v.Placa || 'Sem placa',
                                info: `${v.Modelo || ''} - Capacidade: ${v.Capacidade || 0}`
                            });
                        }
                    });

                    // Processar Rotas
                    rotas.forEach(r => {
                        if (r.Nome_Rota?.toLowerCase().includes(lowerQuery) || 
                            r.Codigo?.toLowerCase().includes(lowerQuery)) {
                            allResults.push({
                                type: 'Rota',
                                name: r.Nome_Rota || 'Sem nome',
                                info: `Código: ${r.Codigo || 'N/A'} - Status: ${r.Status || ''}`
                            });
                        }
                    });
                }

                resultsContainer.innerHTML = `
                    <div class="search-results-list">
                        ${allResults.length > 0 ? allResults.map(result => `
                            <div class="search-result-item">
                                <div class="search-result-icon"><i class="fas fa-search"></i></div>
                                <div class="search-result-content">
                                    <div class="search-result-name">${result.name}</div>
                                    <div class="search-result-info">${result.info}</div>
                                </div>
                                <div class="search-result-type-badge">${result.type}</div>
                            </div>
                        `).join('') : '<p class="empty-state-text">Nenhum resultado encontrado.</p>'}
                    </div>
                `;

                LoadingManager.hide();
                ToastManager.show(`${allResults.length} resultados encontrados`, 'success', 1500);
            } catch (error) {
                console.error('[Search] Erro na busca:', error);
                LoadingManager.hide();
                ToastManager.show('Erro ao realizar busca', 'error', 3000);
                resultsContainer.innerHTML = '<p class="empty-state-text">Erro ao buscar.</p>';
            }
        })();
 };

 // Enter key on search input
        const searchInput = document.getElementById('global-search-input');
 if (searchInput) {
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
 performSearch();
 }
 });
 }

 // ============================================================================
 // CHATBOT MANAGER
 // ============================================================================

 window.sendChatMessage = function() {
            const chatInput = document.getElementById('chatbot-input');
            const messagesContainer = document.getElementById('chatbot-messages');

 if (!chatInput || !messagesContainer) return;

 const message = chatInput.value.trim();
 if (!message) return;

 // Add user message
            const userMessage = document.createElement('div');
            userMessage.className = 'chatbot-message user';
            userMessage.setAttribute('role', 'article');
 userMessage.innerHTML = `
                <div class="chatbot-message-avatar" aria-hidden="true">
                    <i class="fas fa-user"></i>
 </div>
                <div class="chatbot-message-content">
 <p>${Utils.sanitizeHTML(message)}</p>
 </div>
 `;
 messagesContainer.appendChild(userMessage);

            chatInput.value = '';
 messagesContainer.scrollTop = messagesContainer.scrollHeight;

 // Simulated bot response
 setTimeout(() => {
                const botMessage = document.createElement('div');
                botMessage.className = 'chatbot-message bot';
                botMessage.setAttribute('role', 'article');
 botMessage.innerHTML = `
                    <div class="chatbot-message-avatar" aria-hidden="true">
                        <i class="fas fa-robot"></i>
 </div>
                    <div class="chatbot-message-content">
                        <p>Recebi sua mensagem: "${message}". Como posso ajudar?</p>
 </div>
 `;
 messagesContainer.appendChild(botMessage);
 messagesContainer.scrollTop = messagesContainer.scrollHeight;
 }, 1000);
 };

 // ============================================================================
 // VOICE INPUT MANAGER (Web Speech API)
 // ============================================================================

 window.startVoiceInput = function() {
            const chatInput = document.getElementById('chatbot-input');
            const voiceBtn = document.querySelector('.chatbot-voice');

 if (!chatInput || !voiceBtn) return;

 // Check browser support
 const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
 if (!SpeechRecognition) {
                Utils.showToast('Seu navegador não suporta reconhecimento de voz.', 'error');
 return;
 }

 const recognition = new SpeechRecognition();
            recognition.lang = 'pt-BR';
 recognition.continuous = false;
 recognition.interimResults = false;

 // Visual feedback - listening
            voiceBtn.classList.add('listening');
            voiceBtn.innerHTML = '<i class="fas fa-circle" aria-hidden="true"  style="color: var(--error, var(--md-sys-color-error)); animation: pulse 1s infinite"></i>';
 voiceBtn.disabled = true;

 recognition.onresult = (event) => {
 const transcript = event.results[0][0].transcript;
 chatInput.value = transcript;
 chatInput.focus();

                Utils.showToast('Mensagem reconhecida!', 'success');
 };

 recognition.onerror = (event) => {
                console.error('[Voice Input] Erro:', event.error);
                let errorMsg = 'Erro ao reconhecer voz.';

                if (event.error === 'no-speech') {
                    errorMsg = 'Nenhuma fala detectada. Tente novamente.';
                } else if (event.error === 'not-allowed') {
                    errorMsg = 'Permissão de microfone negada.';
                } else if (event.error === 'network') {
                    errorMsg = 'Erro de rede. Verifique sua conexão.';
 }

                Utils.showToast(errorMsg, 'error');
 };

 recognition.onend = () => {
 // Reset button
                voiceBtn.classList.remove('listening');
                voiceBtn.innerHTML = '<i class="fas fa-microphone" aria-hidden="true"></i>';
 voiceBtn.disabled = false;
 };

 // Start recognition
 try {
 recognition.start();
 } catch (error) {
                console.error('[Voice Input] Erro ao iniciar:', error);
                voiceBtn.classList.remove('listening');
                voiceBtn.innerHTML = '<i class="fas fa-microphone" aria-hidden="true"></i>';
 voiceBtn.disabled = false;
                Utils.showToast('Erro ao iniciar reconhecimento de voz.', 'error');
 }
 };

 // Enter key on chatbot input
        const chatInput = document.getElementById('chatbot-input');
 if (chatInput) {
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
 sendChatMessage();
 }
 });
 }

 // ============================================================================
 // TABLE RENDERER
 // ============================================================================

 window.TableRenderer = {
 render(containerId, data, columns, options = {}) {
 const container = document.getElementById(containerId);
 if (!container) {
 console.error(`[TableRenderer] Container não encontrado: ${containerId}`);
 return;
 }

 // Show loading state
 container.innerHTML = `
                    <div class="loading-state text-center"  style="padding: var(--space-8)">
                        <i class="fas fa-spinner fa-spin"  style="font-size: 2rem; color: var(--md-sys-color-primary)"></i>
                        <p  style="margin-top: var(--space-3); color: var(--on-surface-variant)">Carregando dados...</p>
 </div>
 `;

 if (!data || data.length === 0) {
 container.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-box-open empty-state-icon" aria-hidden="true"></i>
                            <p class="empty-state-text">${options.emptyMessage || 'Nenhum dado disponível'}</p>
 </div>
 `;
 return;
 }

                const tableClass = options.tableClassName || 'data-table';

                let html = `<table class="${tableClass}">`;

 // Header
                html += '<thead><tr>';
 columns.forEach(col => {
                    html += `<th scope="col">${col.label}</th>`;
 });
                html += '</tr></thead>';

 // Body
                html += '<tbody>';
 data.forEach(row => {
                    html += '<tr>';
 columns.forEach(col => {
 let cellContent;
 if (col.render) {
 cellContent = col.render(row);
 } else if (col.field) {
                            cellContent = Utils.sanitizeHTML(row[col.field] || '');
 } else {
                            cellContent = '';
 }

                        const className = col.className || '';
                        html += `<td data-label="${col.label}" class="${className}">${cellContent}</td>`;
 });
                    html += '</tr>';
 });
                html += '</tbody>';

                html += '</table>';

 container.innerHTML = html;
 }
 };

 // ============================================================================
 // LOGIN/AUTH UI
 // ============================================================================

 window.showLoginForm = function() {
            const userDrawerContent = document.getElementById('user-drawer-content');
 if (!userDrawerContent) return;

 userDrawerContent.innerHTML = `
                <div class="login-form-container">
                    <div class="auth-header text-center">
                        <h3 class="drawer-view-title">Login</h3>
                        <p class="drawer-view-subtitle">Entre com suas credenciais</p>
 </div>
                    <form id="login-form-1" onsubmit="handleLogin(event)">
                        <div class="form-group">
                            <label for="login-email" class="form-label">E-mail</label>
                            <input type="email" class="form-control" id="login-email" required>
 </div>
                        <div class="form-group">
                            <label for="login-password" class="form-label">Senha</label>
                            <input type="password" class="form-control" id="login-password-1" required>
 </div>
                        <button type="submit" class="btn btn-primary btn-block">
                            <i class="fas fa-sign-in-alt"></i> Entrar
 </button>
                        <button type="button" class="btn btn-text btn-block" onclick="showLoginView()">
                            <i class="fas fa-arrow-left"></i> Voltar
 </button>
 </form>
 </div>
 `;
 };

 window.handleLogin = async function(event) {
 event.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;

            LoadingManager.show('Autenticando...');

 try {
 // Simulated login - Replace with actual backend call
 await new Promise(resolve => setTimeout(resolve, 1500));

 LoadingManager.hide();
                ToastManager.show('Login realizado com sucesso!', 'success');
                closeDrawer('user-drawer');

 // Update UI to show authenticated state
 // ... implement authentication state management
 } catch (error) {
 LoadingManager.hide();
                ToastManager.show('Erro ao fazer login: ' + error.message, 'error');
 }
 };

 window.showLoginView = function() {
            const userDrawerContent = document.getElementById('user-drawer-content');
 if (!userDrawerContent) return;

 userDrawerContent.innerHTML = `
                <div class="login-view-container">
                    <div class="auth-header text-center">
                        <h3 class="drawer-view-title">Bem-vindo!</h3>
                        <p class="drawer-view-subtitle">Acesse para gerenciar o transporte escolar.</p>
 </div>
                    <button class="btn btn-primary btn-block" onclick="showLoginForm()">
                        <i class="fas fa-sign-in-alt"></i> Entrar
 </button>
                    <div class="divider"><span>OU</span></div>
                    <div class="demo-users-section">
 <h4>Acessar como (Demonstração):</h4>
                        <div class="demo-users-list">
                            <button class="demo-login-btn" onclick="alert('Login como Admin...')">
                                <div class="demo-user-content">
 <strong>Administrador</strong>
 <span>Visão completa do sistema</span>
 </div>
                                <span class="demo-role-badge admin">Admin</span>
 </button>
                            <button class="demo-login-btn" onclick="alert('Login como Secretário...')">
                                <div class="demo-user-content">
 <strong>Secretário Escolar</strong>
 <span>Gestão de alunos e frequência</span>
 </div>
                                <span class="demo-role-badge secretario">Escola</span>
 </button>
 </div>
 </div>
 </div>
 `;
 };

 // ============================================================================
 // REFRESH DASHBOARD
 // ============================================================================

 window.refreshDashboard = async function() {
            LoadingManager.show('Atualizando dashboard...');
 try {
 // Simulated refresh - Replace with actual backend call
 await new Promise(resolve => setTimeout(resolve, 1500));

 // Update stats
                document.getElementById('stat-alunos').textContent = Math.floor(Math.random() * 2000);
                document.getElementById('stat-veiculos').textContent = Math.floor(Math.random() * 100);
                document.getElementById('stat-rotas').textContent = Math.floor(Math.random() * 50);

 LoadingManager.hide();
                ToastManager.show('Dashboard atualizado!', 'success');
 } catch (error) {
 LoadingManager.hide();
                ToastManager.show('Erro ao atualizar: ' + error.message, 'error');
 }
 };

        console.log('[Components] Componentes UI inicializados');
 });
})();
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-Core.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 SIG-TE - Sistema Integrado de Gestão de Transporte Escolar
 CORE SYSTEM - API, Loading, Toasts, Utilities

 This script contains the main application logic, organized into a single
 set of managers and a global API client for backend communication.
 ============================================================================ */
(function() {
    'use strict';

 // ============================================================================
 // UTILITY FUNCTIONS - Funções utilitárias para o sistema
 // ============================================================================

 const Utils = {
 debounce(func, wait) {
 let timeout;
 return function executedFunction(...args) {
 const later = () => {
 clearTimeout(timeout);
 func(...args);
 };
 clearTimeout(timeout);
 timeout = setTimeout(later, wait);
 };
 },

 throttle(func, limit) {
 let inThrottle;
 return function(...args) {
 if (!inThrottle) {
 func.apply(this, args);
 inThrottle = true;
 setTimeout(() => inThrottle = false, limit);
 }
 };
 },

 safeQuerySelector(selector, context = document) {
 try {
 return context.querySelector(selector);
 } catch (e) {
 console.error(`[Utils] Erro ao buscar elemento: ${selector}`, e);
 return null;
 }
 },

 safeQuerySelectorAll(selector, context = document) {
 try {
 return context.querySelectorAll(selector);
 } catch (e) {
 console.error(`[Utils] Erro ao buscar elementos: ${selector}`, e);
 return [];
 }
 },

        formatDate(date, format = 'dd/MM/yyyy') {
            if (!date) return '';
 const d = new Date(date);
            const day = String(d.getDate()).padStart(2, '0');
            const month = String(d.getMonth() + 1).padStart(2, '0');
 const year = d.getFullYear();
            return format.replace('dd', day).replace('MM', month).replace('yyyy', year);
 },

 formatCurrency(value) {
            return new Intl.NumberFormat('pt-BR', {
                style: 'currency',
                currency: 'BRL'
 }).format(value);
 },

 sanitizeHTML(str) {
            const div = document.createElement('div');
 div.textContent = str;
 return div.innerHTML;
 }
 };

 window.Utils = Utils; // Expor para outros scripts

 // ============================================================================
 // LOADING MANAGER - Gerenciador de Telas de Carregamento
 // ============================================================================

 const LoadingManager = {
 overlay: null,
 textElement: null,
 progressBar: null,
 progressContainer: null,

 init() {
            this.overlay = document.getElementById('loading-overlay');
 if (!this.overlay) return;
            this.textElement = document.getElementById('loading-text');
            this.progressBar = document.getElementById('loading-progress-bar');
 this.progressContainer = this.progressBar ? this.progressBar.parentElement : null;
 },

        show(text = 'Processando...') {
 if (!this.overlay) this.init();
 if (!this.overlay) return;

 if (this.textElement) this.textElement.textContent = text;
            if (this.progressBar) this.progressBar.style.width = '0%';
 this.updateProgress(0);
            this.overlay.classList.add('active');
            this.overlay.setAttribute('aria-busy', 'true');
            this.overlay.setAttribute('aria-hidden', 'false');
            document.body.classList.add('loading');
 },

 hide() {
 if (!this.overlay) return;
            this.overlay.classList.remove('active');
            this.overlay.setAttribute('aria-busy', 'false');
            this.overlay.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('loading');
 },

 updateText(text) {
 if (!this.textElement) return;
 this.textElement.textContent = text;
 },

 updateProgress(percentage) {
 if (!this.progressBar) return;
 const clampedPercentage = Math.min(100, Math.max(0, percentage));
 this.progressBar.style.width = `${clampedPercentage}%`;

 if (this.progressContainer) {
                this.progressContainer.setAttribute('aria-valuenow', clampedPercentage);
 }
 },

 showButtonLoading(button) {
 if (!button) return;
 button.disabled = true;
 button.dataset.originalText = button.innerHTML;
            button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processando...';
 },

 hideButtonLoading(button) {
 if (!button) return;
 button.disabled = false;
 if (button.dataset.originalText) {
 button.innerHTML = button.dataset.originalText;
 delete button.dataset.originalText;
 }
 }
 };
 window.LoadingManager = LoadingManager; // Expor globalmente

 // ============================================================================
 // TOAST MANAGER - Gerenciador de Notificações (Toasts)
 // ============================================================================

 const ToastManager = {
 container: null,
 toastCounter: 0,

 init() {
            this.container = document.getElementById('toast-container');
 if (!this.container) {
                console.warn('[ToastManager] Container não encontrado');
 }
 },

        show(message, type = 'info', duration = 3000) {
 if (!this.container) this.init();
 if (!this.container) {
 console.log(`[Toast] ${type.toUpperCase()}: ${message}`);
 return;
 }

 const sanitizedMessage = Utils.sanitizeHTML(message);
 const toastId = `toast-${++this.toastCounter}`;

            const toast = document.createElement('div');
 toast.className = `toast ${type}`;
 toast.id = toastId;
            toast.setAttribute('role', 'alert');
            toast.setAttribute('aria-live', type === 'error' ? 'assertive' : 'polite');
            toast.setAttribute('aria-atomic', 'true');

 const icons = {
                info: 'fa-info-circle',
                success: 'fa-check-circle',
                warning: 'fa-exclamation-triangle',
                error: 'fa-times-circle'
 };

 const iconClass = icons[type] || icons.info;
 const title = type.charAt(0).toUpperCase() + type.slice(1);

 toast.innerHTML = `
                <div class="toast-header">
                    <i class="fas ${iconClass} toast-icon" aria-hidden="true"></i>
                    <strong class="toast-title" id="${toastId}-title">${title}</strong>
                    <button class="toast-close" type="button" aria-label="Fechar notificação" data-toast-close>×</button>
 </div>
                <div class="toast-message" id="${toastId}-message">${sanitizedMessage}</div>
                <div class="toast-progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100"></div>
 `;

            const closeBtn = toast.querySelector('[data-toast-close]');
            closeBtn?.addEventListener('click', () => this.closeToast(toast));

 this.container.appendChild(toast);
 requestAnimationFrame(() => {
                toast.classList.add('show');
 });

            const progress = toast.querySelector('.toast-progress');
 if (progress) {
 progress.style.transition = `width ${duration}ms linear`;
 requestAnimationFrame(() => {
                    progress.style.width = '0%';
                    progress.setAttribute('aria-valuenow', '0');
 });
 }

 setTimeout(() => this.closeToast(toast), duration);
 },

 closeToast(toast) {
            if (!toast || !toast.parentElement || toast.classList.contains('closing')) return;
            toast.classList.add('closing');
            toast.classList.remove('show');
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(100%)';
            toast.addEventListener('transitionend', () => {
 toast.remove();
 }, { once: true });
 setTimeout(() => toast.remove(), 500);
 }
 };
 window.ToastManager = ToastManager; // Expor globalmente

 // ============================================================================
 // API CLIENT - Cliente para comunicação com o Backend (Google Apps Script)
 // ============================================================================

 const API = {
 timeout: 30000,
 pendingRequests: new Map(),
        isGasEnvironment: typeof google !== 'undefined' && google.script?.run,

 run(action, payload = {}) {
            LoadingManager.show('Processando sua solicitação...');
 console.log(`[API Request] Ação: ${action}`, payload);

 if (this.isGasEnvironment) {
 return this.executeGASAction(action, payload);
 } else {
            LoadingManager.hide();
            const errorMsg = 'Sistema deve ser executado no Google Apps Script. Ambiente de desenvolvimento não suportado.';
            console.error('[API] ' + errorMsg);
            ToastManager.show(errorMsg, 'error', 5000);
            return Promise.reject(new Error(errorMsg));
 }
 },

 executeGASAction(action, payload) {
 return new Promise((resolve, reject) => {
 const requestId = `${action}-${Date.now()}`;
 this.pendingRequests.set(requestId, { action, payload, timestamp: Date.now() });

 const timeoutId = setTimeout(() => {
 this.pendingRequests.delete(requestId);
 LoadingManager.hide();
                    reject(new Error('Timeout: A requisição demorou mais de 30 segundos'));
 }, this.timeout);

 google.script.run
 .withSuccessHandler((response) => {
 clearTimeout(timeoutId);
 this.pendingRequests.delete(requestId);
 LoadingManager.hide();
 console.log(`[API Response] ${action}:`, response);
 resolve(response);
 })
 .withFailureHandler((error) => {
 clearTimeout(timeoutId);
 this.pendingRequests.delete(requestId);
 LoadingManager.hide();
 console.error(`[API Error] ${action}:`, error);
 reject(error);
 })
 [action](payload);
 });
 }
};
window.API = API; // Expor globalmente

 // ============================================================================
 // LOGGER - Sistema de Logging
 // ============================================================================

 const Logger = {
 enabled: true,
        logLevel: 'INFO', // DEBUG, INFO, WARN, ERROR

 levels: {
 DEBUG: 0,
 INFO: 1,
 WARN: 2,
 ERROR: 3
 },

 log(level, ...args) {
 if (!this.enabled) return;
 if (this.levels[level] < this.levels[this.logLevel]) return;

 const timestamp = new Date().toISOString();
 const prefix = `[${timestamp}] [${level}]`;

 switch(level) {
                case 'ERROR':
 console.error(prefix, ...args);
 break;
                case 'WARN':
 console.warn(prefix, ...args);
 break;
                case 'DEBUG':
 console.debug(prefix, ...args);
 break;
 default:
 console.log(prefix, ...args);
 }
 },

        debug(...args) { this.log('DEBUG', ...args); },
        info(...args) { this.log('INFO', ...args); },
        warn(...args) { this.log('WARN', ...args); },
        error(...args) { this.log('ERROR', ...args); }
 };
 window.Logger = Logger; // Expor globalmente

 // ============================================================================
 // INICIALIZAÇÃO
 // ============================================================================

    document.addEventListener('DOMContentLoaded', () => {
 LoadingManager.init();
 ToastManager.init();
        Logger.info('[Core] Sistema inicializado com sucesso');
 });

})();
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-DebugTools.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 DEBUG TOOLS & DIAGNOSTICS
 Ferramentas de debug e diagnóstico para desenvolvimento
 ============================================================================ */

(function(window) {
    'use strict';

 /**
 * Gerenciador de Ferramentas de Debug
 */
 const DebugTools = {

 enabled: false,
 logHistory: [],
 maxHistorySize: 100,

 /**
 * Ativa modo debug
 */
 enable() {
 this.enabled = true;
            console.log('%c[DebugTools] 🔧 Modo debug ATIVADO', 'color: #00ff00; font-weight: bold;');
 this.showDebugPanel();
 },

 /**
 * Desativa modo debug
 */
 disable() {
 this.enabled = false;
            console.log('%c[DebugTools] Modo debug desativado', 'color: #ff0000;');
 this.hideDebugPanel();
 },

 /**
 * Toggle modo debug
 */
 toggle() {
 if (this.enabled) {
 this.disable();
 } else {
 this.enable();
 }
 },

 /**
 * Loga mensagem no histórico
 */
 log(category, message, data = null) {
 const entry = {
 timestamp: new Date(),
 category,
 message,
 data
 };

 this.logHistory.unshift(entry);

 // Limita tamanho do histórico
 if (this.logHistory.length > this.maxHistorySize) {
 this.logHistory.pop();
 }

 if (this.enabled) {
 const style = this.getCategoryStyle(category);
                console.log(`%c[${category}] ${message}`, style, data || '');
 }
 },

 /**
 * Retorna estilo CSS para categoria
 */
 getCategoryStyle(category) {
 const styles = {
                'FORM': 'color: var(--md-sys-color-primary); font-weight: bold;',
                'CRUD': 'color: var(--md-sys-color-success); font-weight: bold;',
                'VALIDATION': 'color: var(--md-sys-color-warning); font-weight: bold;',
                'CALCULATION': 'color: var(--md-sys-color-tertiary); font-weight: bold;',
                'API': 'color: var(--md-sys-color-error); font-weight: bold;',
                'PERFORMANCE': 'color: #00BCD4; font-weight: bold;',
                'ERROR': 'color: #f00; font-weight: bold; background: #ffe0e0;'
 };
            return styles[category] || 'color: #666;';
 },

 /**
 * Verifica estado do sistema
 */
 checkSystem() {
 const report = {
 timestamp: new Date().toISOString(),
 modules: {},
 sections: {},
 forms: {},
 issues: []
 };

 // Verifica módulos carregados
 report.modules = {
                API: typeof window.API !== 'undefined',
                CRUDManagerUniversal: typeof window.CRUDManagerUniversal !== 'undefined',
                FormBuilder: typeof window.FormBuilder !== 'undefined',
                ModalManager: typeof window.ModalManager !== 'undefined',
                SheetMappingManager: typeof window.SheetMappingManager !== 'undefined',
                CalculatedFieldsManager: typeof window.CalculatedFieldsManager !== 'undefined',
                AutoFillManager: typeof window.AutoFillManager !== 'undefined',
                CustomValidator: typeof window.CustomValidator !== 'undefined',
                InputMasksManager: typeof window.InputMasksManager !== 'undefined',
                CustomFormsIntegration: typeof window.CustomFormsIntegration !== 'undefined'
 };

 // Verifica instâncias CRUD
 if (window.CRUDManagerUniversal) {
 report.sections = Object.keys(window.CRUDManagerUniversal.instances || {});
 report.forms = Object.keys(window.CRUDManagerUniversal.customFormHandlers || {});
 }

 // Identifica problemas
 Object.entries(report.modules).forEach(([module, loaded]) => {
 if (!loaded) {
                    report.issues.push(`Módulo '${module}' não carregado`);
 }
 });

 console.table(report.modules);
            console.log('Seções inicializadas:', report.sections);
            console.log('Formulários registrados:', report.forms);

 if (report.issues.length > 0) {
                console.warn('⚠️ Problemas encontrados:', report.issues);
 } else {
                console.log('✅ Sistema OK');
 }

 return report;
 },

 /**
 * Testa funcionalidade específica
 */
 test(testName) {
 console.group(`🧪 Testando: ${testName}`);

 const tests = {
                'campos-calculados': () => this.testCalculatedFields(),
                'validacoes': () => this.testValidations(),
                'mascaras': () => this.testMasks(),
                'crud': () => this.testCRUD(),
                'formularios': () => this.testForms(),
                'mapeamento': () => this.testMapping(),
                'carregamento-crud': () => this.testCrudLoad(),
                'abertura-forms': () => this.testFormOpening()
 };

 const testFn = tests[testName];
 if (testFn) {
 try {
 testFn();
                    console.log('✅ Teste concluído');
 } catch (error) {
                    console.error('❌ Teste falhou:', error);
 }
 } else {
                console.error(`❌ Teste '${testName}' não encontrado`);
                console.log('Testes disponíveis:', Object.keys(tests));
 }

 console.groupEnd();
 },

 /**
 * Testa campos calculados
 */
 testCalculatedFields() {
 if (!window.CalculatedFieldsManager) {
                throw new Error('CalculatedFieldsManager não disponível');
 }

 const configs = window.CalculatedFieldsManager.calculations;
            console.log('Configurações de cálculo:', configs);

 Object.keys(configs).forEach(sectionId => {
                console.log(`✓ Seção '${sectionId}': ${configs[sectionId].length} cálculos configurados`);
 });
 },

 /**
 * Testa validações
 */
 testValidations() {
 if (!window.CustomValidator) {
                throw new Error('CustomValidator não disponível');
 }

 const tests = [
                { type: 'CPF', value: '123.456.789-01', expected: false },
                { type: 'CPF', value: '111.111.111-11', expected: false },
                { type: 'Placa', value: 'ABC-1234', expected: true },
                { type: 'Placa', value: 'ABC1D23', expected: true },
                { type: 'Phone', value: '(61) 99999-1234', expected: true }
 ];

 tests.forEach(test => {
 let result;
 switch(test.type) {
                    case 'CPF':
 result = window.CustomValidator.validateCPF(test.value);
 break;
                    case 'Placa':
 result = window.CustomValidator.validatePlaca(test.value);
 break;
                    case 'Phone':
 result = window.CustomValidator.validatePhone(test.value);
 break;
 }

                const status = result === test.expected ? '✅' : '❌';
 console.log(`${status} ${test.type}: ${test.value} → ${result}`);
 });
 },

 /**
 * Testa máscaras
 */
 testMasks() {
 if (!window.InputMasksManager) {
                throw new Error('InputMasksManager não disponível');
 }

 const masks = window.InputMasksManager.masks;
            console.log('Máscaras disponíveis:', Object.keys(masks));

 const tests = [
                { mask: 'cpf', input: '12345678901', expected: '123.456.789-01' },
                { mask: 'phone', input: '61999991234', expected: '(61) 99999-1234' },
                { mask: 'cep', input: '72110120', expected: '72110-120' }
 ];

 tests.forEach(test => {
 const result = maskstest.mask;
                const status = result === test.expected ? '✅' : '❌';
 console.log(`${status} ${test.mask}: ${test.input} → ${result}`);
 });
 },

 /**
 * Testa CRUD
 */
 testCRUD() {
 if (!window.CRUDManagerUniversal) {
                throw new Error('CRUDManagerUniversal não disponível');
 }

 const instances = Object.keys(window.CRUDManagerUniversal.instances);
 const handlers = Object.keys(window.CRUDManagerUniversal.customFormHandlers);

 console.log(`Instâncias CRUD: ${instances.length}`);
 console.log(instances);
 console.log(`Handlers customizados: ${handlers.length}`);
 console.log(handlers);

 instances.forEach(sectionId => {
 const hasCustom = window.CRUDManagerUniversal.hasCustomForm(sectionId);
                console.log(`${hasCustom ? '📝' : '📋'} ${sectionId}`);
 });
 },

 /**
 * Testa formulários
 */
 testForms() {
            const forms = document.querySelectorAll('form[id^="form-"]');
 console.log(`Formulários encontrados: ${forms.length}`);

 forms.forEach(form => {
                const fields = form.querySelectorAll('input, select, textarea');
 console.log(`📝 ${form.id}: ${fields.length} campos`);
 });
 },

 /**
 * Testa se o mapeamento do frontend corresponde ao backend
 */
 async testMapping() {
            if (!window.SheetMappingManager) throw new Error('SheetMappingManager não disponível');

            console.log('Validando mapeamento de seções...');
 await SheetMappingManager.validateMapping();
 },

 /**
 * Testa o carregamento de dados de todas as seções CRUD
 */
 async testCrudLoad() {
            if (!window.CRUDManagerUniversal) throw new Error('CRUDManagerUniversal não disponível');

 const instances = Object.keys(window.CRUDManagerUniversal.instances);
 console.log(`Testando carregamento de dados para ${instances.length} seções CRUD...`);

 for (const sectionId of instances) {
 try {
 await window.CRUDManagerUniversal.loadData(sectionId);
                    console.log(`✅ Dados para '${sectionId}' carregados com sucesso.`);
 } catch (error) {
                    console.error(`❌ Falha ao carregar dados para '${sectionId}':`, error);
 }
 }
 },

 /**
 * Testa a abertura de todos os formulários de criação
 */
 testFormOpening() {
            if (!window.CRUDManagerUniversal) throw new Error('CRUDManagerUniversal não disponível');

 const instances = Object.keys(window.CRUDManagerUniversal.instances);
 instances.forEach(sectionId => {
                console.log(`Testando abertura do formulário para '${sectionId}'...`);
 window.CRUDManagerUniversal.openCreateModal(sectionId);
 });
 },

 /**
 * Monitora performance
 */
 startPerformanceMonitor() {
 this.performanceMarks = {};

            console.log('⏱️ Monitor de performance iniciado');
            console.log('Use: DebugTools.mark("nome") e DebugTools.measure("nome")');
 },

 /**
 * Marca início de medição
 */
 mark(name) {
 this.performanceMarks = this.performanceMarks || {};
 this.performanceMarks[name] = performance.now();
            this.log('PERFORMANCE', `Marca '${name}' registrada`);
 },

 /**
 * Mede tempo desde marca
 */
 measure(name) {
 if (!this.performanceMarks || !this.performanceMarks[name]) {
                console.warn(`Marca '${name}' não encontrada`);
 return null;
 }

 const elapsed = performance.now() - this.performanceMarks[name];
            this.log('PERFORMANCE', `${name}: ${elapsed.toFixed(2)}ms`);
 return elapsed;
 },

 /**
 * Mostra painel de debug
 */
 showDebugPanel() {
 // Remove painel existente se houver
 this.hideDebugPanel();

            const panel = document.createElement('div');
            panel.id = 'debug-panel';
 panel.innerHTML = `
                <div  style="position: fixed; bottom: 20px; right: 20px; background: var(--md-sys-color-surface-container-low); color: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 99999; font-family: monospace; font-size: 12px; max-width: 300px">
                    <div  class="flex items-center" style="justify-content: space-between; margin-bottom: 10px">
 <strong>🔧 Debug Tools</strong>
                        <button onclick="DebugTools.hideDebugPanel()"
                                 style="background: var(--md-sys-color-error); border: none; color: white; padding: 2px 8px; border-radius: 4px; cursor: pointer">✕</button>
 </div>
                    <div  class="flex" style="flex-direction: column; gap: 5px">
                        <button onclick="DebugTools.checkSystem()"
                                 style="background: var(--md-sys-color-primary); border: none; color: white; padding: 5px; border-radius: 4px; cursor: pointer">
 ✅ Verificar Sistema
 </button>
                        <button onclick="DebugTools.test('campos-calculados')"
                                 style="background: var(--md-sys-color-success); border: none; color: white; padding: 5px; border-radius: 4px; cursor: pointer">
 🧮 Testar Cálculos
 </button>
                        <button onclick="DebugTools.test('validacoes')"
                                 style="background: var(--md-sys-color-warning); border: none; color: white; padding: 5px; border-radius: 4px; cursor: pointer">
 ✔️ Testar Validações
 </button>
                        <button onclick="DebugTools.test('mapeamento')"
                                 style="background: #673AB7; border: none; color: white; padding: 5px; border-radius: 4px; cursor: pointer">
 🗺️ Testar Mapeamento
 </button>
                        <button onclick="console.clear()"
                                 style="background: #9E9E9E; border: none; color: white; padding: 5px; border-radius: 4px; cursor: pointer">
 🗑️ Limpar Console
 </button>
 </div>
                    <div  style="margin-top: 10px; font-size: 10px; color: #888">
 Abra o console (F12) para ver detalhes
 </div>
 </div>
 `;

 document.body.appendChild(panel);
 },

 /**
 * Esconde painel de debug
 */
 hideDebugPanel() {
            const panel = document.getElementById('debug-panel');
 if (panel) {
 panel.remove();
 }
 },

 /**
 * Exporta logs
 */
 exportLogs() {
 const logs = JSON.stringify(this.logHistory, null, 2);
            const blob = new Blob([logs], { type: 'application/json' });
 const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
 a.href = url;
 a.download = `debug-logs-${new Date().toISOString()}.json`;
 a.click();

 URL.revokeObjectURL(url);
            console.log('📥 Logs exportados');
 },

 /**
 * Limpa histórico
 */
 clearHistory() {
 this.logHistory = [];
            console.log('🗑️ Histórico limpo');
 }
 };

 // Exporta para escopo global
 window.DebugTools = DebugTools;

 // Atalho de teclado: Ctrl+Shift+D para toggle debug
    document.addEventListener('keydown', function(e) {
 // Habilita o atalho apenas em ambiente de desenvolvimento
        if (Logger && Logger.environment === 'development') {
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
 e.preventDefault();
 DebugTools.toggle();
 }
 }
 });

    console.log('[DebugTools] Módulo carregado');
    console.log('💡 Dica: Use Ctrl+Shift+D para ativar/desativar debug');
    console.log('💡 Comandos disponíveis:');
    console.log('   - DebugTools.enable()');
    console.log('   - DebugTools.checkSystem()');
    console.log('   - DebugTools.test("nome-do-teste")');

})(window);
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-DrawerManager.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 DRAWER MANAGER V3 - TESTE
 ============================================================================ */
(function() {
    'use strict';

    console.log('[DrawerManager] 🚀 Inicializando...');

 function getBackdrop(drawerId) {
        return document.getElementById(drawerId + '-backdrop');
 }

 function openDrawer(drawerId, triggerElement) {
 const drawer = document.getElementById(drawerId);
 if (!drawer) {
            console.error('[DrawerManager] ❌ Drawer não encontrado:', drawerId);
 return;
 }

        console.log('[DrawerManager] ✅ Abrindo:', drawerId);

 // Fechar outros drawers
        const allActive = document.querySelectorAll('.app-drawer.active, .drawer.is-active');
 allActive.forEach(function(d) {
 if (d.id !== drawerId) {
                d.classList.remove('active', 'is-active');
 const oldBackdrop = getBackdrop(d.id);
                if (oldBackdrop) oldBackdrop.classList.remove('active');
 }
 });

 // Ativar backdrop
 const backdrop = getBackdrop(drawerId);
 if (backdrop) {
            backdrop.classList.add('active');
            console.log('[DrawerManager] ✅ Backdrop ativado para', drawerId);
 }

 // ESPECIAL: Se for projects-drawer, garantir propriedades corretas
        if (drawerId === 'projects-drawer') {
            drawer.style.opacity = '1';
            drawer.style.visibility = 'visible';
            drawer.style.pointerEvents = 'all';
            drawer.style.transform = 'scale(1) translateY(0) translateX(0)';
 }

 // Ativar drawer
        drawer.classList.add('active', 'is-active');
 }

 function closeDrawer(drawerId) {
 const drawer = document.getElementById(drawerId);
 if (!drawer) return;

        console.log('[DrawerManager] 🔒 Fechando:', drawerId);

 const backdrop = getBackdrop(drawerId);
 if (backdrop) {
            backdrop.classList.remove('active');
 }

        drawer.classList.remove('active', 'is-active');

 // ESPECIAL: Se for projects-drawer, garantir que fica invisível
        if (drawerId === 'projects-drawer') {
            drawer.style.opacity = '0';
            drawer.style.visibility = 'hidden';
            drawer.style.pointerEvents = 'none';
            drawer.style.transform = 'scale(0.92) translateY(-12px) translateX(-12px)';
 }
 }

 function initDrawerListeners() {
        console.log('[DrawerManager] 🎯 Configurando event listeners...');

        document.addEventListener('click', function(e) {
            const trigger = e.target.closest('[data-drawer-target]');
 if (trigger) {
 e.preventDefault();
 const drawerId = trigger.dataset.drawerTarget;
                console.log('[DrawerManager] 🖱️ Clique detectado:', drawerId);
 if (drawerId) {
 openDrawer(drawerId, trigger);
 }
 return;
 }

            if (e.target.classList.contains('drawer-backdrop')) {
                const drawerId = e.target.id.replace('-backdrop', '');
                console.log('[DrawerManager] 🖱️ Clique no backdrop');
 if (drawerId) {
 closeDrawer(drawerId);
 }
 return;
 }

            const closeBtn = e.target.closest('.drawer-close-btn');
 if (closeBtn) {
 e.preventDefault();
                const drawer = closeBtn.closest('.app-drawer, .drawer');
 if (drawer) {
                    console.log('[DrawerManager] 🖱️ Clique no botão fechar');
 closeDrawer(drawer.id);
 }
 }
 }, true);

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const activeDrawer = document.querySelector('.app-drawer.active, .drawer.is-active');
 if (activeDrawer) {
                    console.log('[DrawerManager] ⌨️ ESC pressionado');
 closeDrawer(activeDrawer.id);
 }
 }
 });

        console.log('[DrawerManager] ✅ Event listeners configurados!');
 }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initDrawerListeners);
 } else {
 initDrawerListeners();
 }

 // FORÇAR projects-drawer a ter mesmas propriedades do search-drawer
 setTimeout(() => {
        const projectsDrawer = document.getElementById('projects-drawer');
        const searchDrawer = document.getElementById('search-drawer');

 if (projectsDrawer && searchDrawer) {
 // Copiar computed styles do search-drawer
 const searchStyles = window.getComputedStyle(searchDrawer);

            console.log('[DrawerManager] 🔧 FORÇANDO projects-drawer igual a search-drawer');

 // Garantir que tem a classe correta
            if (!projectsDrawer.classList.contains('app-drawer')) {
                console.warn('[DrawerManager] ⚠️ projects-drawer NÃO tem class="app-drawer"! Corrigindo...');
                projectsDrawer.classList.add('app-drawer');
                projectsDrawer.classList.remove('drawer');
 }

 // Remover qualquer classe active/is-active
            projectsDrawer.classList.remove('active', 'is-active');

 // Forçar propriedades inline para garantir
            projectsDrawer.style.position = 'fixed';
            projectsDrawer.style.width = '360px';
            projectsDrawer.style.maxHeight = 'calc(100vh - 120px)';
            projectsDrawer.style.top = 'calc(var(--space-4) + 4.2rem + var(--space-2))';
            projectsDrawer.style.left = 'var(--space-4)';
            projectsDrawer.style.right = 'auto';
            projectsDrawer.style.opacity = '0';
            projectsDrawer.style.visibility = 'hidden';
            projectsDrawer.style.pointerEvents = 'none';
            projectsDrawer.style.transform = 'scale(0.92) translateY(-12px) translateX(-12px)';
            projectsDrawer.style.transformOrigin = 'top left';
            projectsDrawer.style.zIndex = 'var(--z-modal, 9999)';

            console.log('[DrawerManager] ✅ projects-drawer FORÇADO para posição correta');
 }

 // DEBUG: Verificar estado inicial dos drawers
        console.log('[DrawerManager] 🔍 DEBUG - Estado dos drawers:');
        const allDrawers = document.querySelectorAll('[id$="-drawer"]');
 allDrawers.forEach(drawer => {
 const classes = drawer.className;
            const hasActive = drawer.classList.contains('active') || drawer.classList.contains('is-active');
 const computed = window.getComputedStyle(drawer);
 console.log(` 📦 ${drawer.id}:`, {
 classes: classes,
 active: hasActive,
 width: computed.width,
 top: computed.top,
 left: computed.left,
 opacity: computed.opacity,
 visibility: computed.visibility
 });
 });
 }, 500);

 window.openDrawer = openDrawer;
 window.closeDrawer = closeDrawer;

    console.log('[DrawerManager] 🎉 Módulo carregado!');
})();
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-DynamicDataLoader.html -->
<!--============================================================================-->

<script>
/**
 * ============================================================================
 * JS-DynamicDataLoader.html - Sistema de Carregamento Dinâmico de Dados
 * ============================================================================
 * Elimina dados mock e carrega tudo dinamicamente do Google Sheets via backend
 * Substitui: mockStudents, mockRoutes, mockVehicles, mockDashboardData, etc.
 * ============================================================================
 */

(function(window) {
  'use strict';

 /**
 * DynamicDataLoader - Gerenciador central de dados dinâmicos
 */
 class DynamicDataLoader {
 constructor() {
 this.cache = new Map();
 this.cacheExpiry = new Map();
 this.cacheDuration = 5 * 60 * 1000; // 5 minutos
 this.isLoading = new Set();
 }

 /**
 * Carrega dados de uma planilha com cache inteligente
 * @param {string} sheetName - Nome da planilha
 * @param {Object} filters - Filtros opcionais
 * @param {boolean} forceRefresh - Força atualização do cache
 * @returns {Promise<Array>}
 */
 async load(sheetName, filters = {}, forceRefresh = false) {
 const cacheKey = this._getCacheKey(sheetName, filters);

 // Verifica cache válido
 if (!forceRefresh && this._isCacheValid(cacheKey)) {
 console.log(`[DataLoader] 📦 Usando cache: ${sheetName}`);
 return this.cache.get(cacheKey) || [];
 }

 // Evita múltiplas requisições simultâneas
 if (this.isLoading.has(cacheKey)) {
 console.log(`[DataLoader] ⏳ Aguardando requisição em andamento: ${sheetName}`);
 return this._waitForLoading(cacheKey);
 }

 this.isLoading.add(cacheKey);

 try {
 console.log(`[DataLoader] 🔄 Carregando do backend: ${sheetName}`, filters);

        if (typeof window.LoadingManager !== 'undefined') {
 window.LoadingManager.show(`Carregando ${sheetName}...`);
 }

 const data = await this._fetchFromBackend(sheetName, filters);

 // Atualiza cache
 this.cache.set(cacheKey, data);
 this.cacheExpiry.set(cacheKey, Date.now() + this.cacheDuration);

 console.log(`[DataLoader] ✅ Dados carregados: ${sheetName} (${data.length} registros)`);

 return data;

 } catch (error) {
 console.error(`[DataLoader] ❌ Erro ao carregar ${sheetName}:`, error);

        if (typeof window.ToastManager !== 'undefined') {
          window.ToastManager.show(`Erro ao carregar ${sheetName}`, 'error');
 }

 // Retorna cache antigo se disponível
 return this.cache.get(cacheKey) || [];

 } finally {
 this.isLoading.delete(cacheKey);

        if (typeof window.LoadingManager !== 'undefined') {
 window.LoadingManager.hide();
 }
 }
 }

 /**
 * Carrega dados de múltiplas planilhas em paralelo
 * @param {Array<{sheet: string, filters?: Object}>} requests
 * @returns {Promise<Object>}
 */
 async loadMultiple(requests) {
 const promises = requests.map(req =>
 this.load(req.sheet, req.filters || {})
 .then(data => ({ [req.sheet]: data }))
 );

 const results = await Promise.allSettled(promises);

 return results.reduce((acc, result) => {
        if (result.status === 'fulfilled') {
 Object.assign(acc, result.value);
 }
 return acc;
 }, {});
 }

 /**
 * Carrega dados do dashboard (agregados)
 * @returns {Promise<Object>}
 */
 async loadDashboardMetrics() {
 try {
 const [students, routes, vehicles, attendance] = await Promise.all([
          this.load('Alunos'),
          this.load('Rotas'),
          this.load('Veiculos'),
          this.load('Frequencia')
 ]);

 // Calcula métricas agregadas
 const metrics = {
 totalStudents: students.length,
          activeRoutes: routes.filter(r => r.Status === 'Ativa' || r.Status === 'ativa').length,
          activeVehicles: vehicles.filter(v => v.Status === 'Operacional' || v.Status === 'Ativo').length,
          maintenanceVehicles: vehicles.filter(v => v.Status === 'Manutenção' || v.Status === 'manutencao').length,
 averageAttendance: this._calculateAverageAttendance(attendance),
 monthlyKm: this._calculateMonthlyKm(vehicles),
 fuelConsumption: this._calculateFuelConsumption(vehicles),
 complianceScore: this._calculateComplianceScore(students, routes, vehicles),
 pendingIssues: 0, // TODO: Implementar
 completedTrips: attendance.length,
 onTimePerformance: this._calculateOnTimePerformance(attendance),
 parentSatisfaction: 4.3 // TODO: Implementar sistema de avaliação
 };

        console.log('[DataLoader] 📊 Dashboard metrics calculados:', metrics);
 return metrics;

 } catch (error) {
        console.error('[DataLoader] ❌ Erro ao calcular métricas do dashboard:', error);
 return this._getDefaultMetrics();
 }
 }

 /**
 * Invalida cache de uma ou todas as planilhas
 * @param {string|null} sheetName - Nome da planilha ou null para limpar tudo
 */
 invalidateCache(sheetName = null) {
 if (sheetName) {
 const keysToDelete = [];
 for (const key of this.cache.keys()) {
 if (key.startsWith(`${sheetName}:`)) {
 keysToDelete.push(key);
 }
 }
 keysToDelete.forEach(key => {
 this.cache.delete(key);
 this.cacheExpiry.delete(key);
 });
 console.log(`[DataLoader] 🗑️ Cache invalidado: ${sheetName}`);
 } else {
 this.cache.clear();
 this.cacheExpiry.clear();
        console.log('[DataLoader] 🗑️ Todo cache invalidado');
 }
 }

 // ===== MÉTODOS PRIVADOS =====

 async _fetchFromBackend(sheetName, filters) {
 // Usa o sistema API existente (JS-Core.html)
      if (window.API && typeof window.API.run === 'function') {
        const result = await window.API.run('readRecords', {
 sheetName: sheetName,
 filters: filters
 });

 return Array.isArray(result) ? result : (result.data || []);
 }

 // Fallback: google.script.run direto
      if (typeof google !== 'undefined' && google.script && google.script.run) {
 return new Promise((resolve, reject) => {
 google.script.run
 .withSuccessHandler((result) => {
 const data = result.success ? result.data : result;
 resolve(Array.isArray(data) ? data : []);
 })
 .withFailureHandler(reject)
 .readRecords({ sheetName, filters });
 });
 }

      throw new Error('Sistema de API não disponível');
 }

 _getCacheKey(sheetName, filters) {
 const filterStr = JSON.stringify(filters);
 return `${sheetName}:${filterStr}`;
 }

 _isCacheValid(cacheKey) {
 if (!this.cache.has(cacheKey)) return false;
 const expiry = this.cacheExpiry.get(cacheKey);
 return expiry && Date.now() < expiry;
 }

 async _waitForLoading(cacheKey) {
 // Aguarda até 30 segundos
 const maxWait = 30000;
 const interval = 100;
 let waited = 0;

 while (this.isLoading.has(cacheKey) && waited < maxWait) {
 await new Promise(resolve => setTimeout(resolve, interval));
 waited += interval;
 }

 return this.cache.get(cacheKey) || [];
 }

 // ===== CÁLCULOS DE MÉTRICAS =====

 _calculateAverageAttendance(attendance) {
 if (!attendance || attendance.length === 0) return 0;
      const present = attendance.filter(a => a.Status === 'Presente' || a.Presenca === 'Sim').length;
 return ((present / attendance.length) * 100).toFixed(1);
 }

 _calculateMonthlyKm(vehicles) {
 if (!vehicles || vehicles.length === 0) return 0;
 const totalKm = vehicles.reduce((sum, v) => {
 const km = parseFloat(v.Km_Rodados || v.Quilometragem || 0);
 return sum + km;
 }, 0);
 return Math.round(totalKm);
 }

 _calculateFuelConsumption(vehicles) {
 if (!vehicles || vehicles.length === 0) return 0;
 const totalFuel = vehicles.reduce((sum, v) => {
 const fuel = parseFloat(v.Consumo_Combustivel || v.Litros || 0);
 return sum + fuel;
 }, 0);
 return totalFuel.toFixed(1);
 }

 _calculateComplianceScore(students, routes, vehicles) {
 // Score de conformidade baseado em múltiplos fatores
 let score = 100;

 // Penaliza por dados incompletos
 const totalRecords = students.length + routes.length + vehicles.length;
 if (totalRecords === 0) return 0;

 // Verifica campos obrigatórios
 const studentsValid = students.filter(s => s.CPF && s.Nome).length;
 const routesValid = routes.filter(r => r.Codigo && r.Nome_Rota).length;
 const vehiclesValid = vehicles.filter(v => v.Placa && v.Status).length;

 const validPercentage = ((studentsValid + routesValid + vehiclesValid) / totalRecords) * 100;
 score = Math.min(100, Math.max(0, validPercentage));

 return score.toFixed(1);
 }

 _calculateOnTimePerformance(attendance) {
 if (!attendance || attendance.length === 0) return 0;
 const onTime = attendance.filter(a => {
 const status = a.Pontualidade || a.Status_Horario;
        return status === 'No horário' || status === 'Pontual';
 }).length;
 return ((onTime / attendance.length) * 100).toFixed(1);
 }

 _getDefaultMetrics() {
 return {
 totalStudents: 0,
 activeRoutes: 0,
 activeVehicles: 0,
 maintenanceVehicles: 0,
 averageAttendance: 0,
 monthlyKm: 0,
 fuelConsumption: 0,
 complianceScore: 0,
 pendingIssues: 0,
 completedTrips: 0,
 onTimePerformance: 0,
 parentSatisfaction: 0
 };
 }
 }

 // ===== FUNÇÕES AUXILIARES DE ALTO NÍVEL =====

 /**
 * Popula um select com dados dinâmicos
 * @param {string} selectId - ID do elemento select
 * @param {string} sheetName - Nome da planilha
 * @param {Object} options - Configurações
 */
 async function populateSelect(selectId, sheetName, options = {}) {
 const select = document.getElementById(selectId);
 if (!select) {
 console.warn(`[DataLoader] Select não encontrado: ${selectId}`);
 return;
 }

 const {
      valueField = 'ID',
      labelFields = ['Nome'],
      placeholder = 'Selecione...',
 filters = {}
 } = options;

 try {
 const data = await window.DataLoader.load(sheetName, filters);

      select.innerHTML = `<option value="">${placeholder}</option>`;

 data.forEach(item => {
 const value = item[valueField];
        const label = labelFields.map(field => item[field]).filter(Boolean).join(' - ');

        const option = document.createElement('option');
 option.value = value;
 option.textContent = label;
 select.appendChild(option);
 });

 console.log(`[DataLoader] ✅ Select populado: ${selectId} (${data.length} opções)`);

 } catch (error) {
 console.error(`[DataLoader] ❌ Erro ao popular select ${selectId}:`, error);
      select.innerHTML = `<option value="">Erro ao carregar</option>`;
 }
 }

 /**
 * Popula uma tabela com dados dinâmicos
 * @param {string} tableId - ID do elemento table/tbody
 * @param {string} sheetName - Nome da planilha
 * @param {Function} renderRow - Função para renderizar cada linha
 */
 async function populateTable(tableId, sheetName, renderRow, filters = {}) {
 const tbody = document.querySelector(`#${tableId} tbody`) || document.getElementById(tableId);
 if (!tbody) {
 console.warn(`[DataLoader] Tabela não encontrada: ${tableId}`);
 return;
 }

 try {
 const data = await window.DataLoader.load(sheetName, filters);

 if (data.length === 0) {
        tbody.innerHTML = '<tr><td colspan="100%" class="text-center">Nenhum registro encontrado</td></tr>';
 return;
 }

      tbody.innerHTML = data.map(renderRow).join('');
 console.log(`[DataLoader] ✅ Tabela populada: ${tableId} (${data.length} linhas)`);

 } catch (error) {
 console.error(`[DataLoader] ❌ Erro ao popular tabela ${tableId}:`, error);
      tbody.innerHTML = '<tr><td colspan="100%" class="text-center text-error">Erro ao carregar dados</td></tr>';
 }
 }

 /**
 * Atualiza cards de métricas do dashboard
 */
 async function updateDashboardCards() {
 try {
 const metrics = await window.DataLoader.loadDashboardMetrics();

 // Mapeia IDs dos elementos com os valores
 const mappings = {
        'total-students': metrics.totalStudents,
        'active-routes': metrics.activeRoutes,
        'active-vehicles': metrics.activeVehicles,
        'average-attendance': metrics.averageAttendance + '%',
        'monthly-km': metrics.monthlyKm.toLocaleString('pt-BR'),
        'fuel-consumption': metrics.fuelConsumption,
        'compliance-score': metrics.complianceScore + '%',
        'pending-issues': metrics.pendingIssues,
        'completed-trips': metrics.completedTrips,
        'ontime-performance': metrics.onTimePerformance + '%',
        'parent-satisfaction': metrics.parentSatisfaction
 };

 Object.entries(mappings).forEach(([id, value]) => {
        const el = document.getElementById(id) || document.querySelector(`[data-metric="${id}"]`);
 if (el) {
 el.textContent = value;
 }
 });

      console.log('[DataLoader] ✅ Dashboard atualizado com dados dinâmicos');

 } catch (error) {
      console.error('[DataLoader] ❌ Erro ao atualizar dashboard:', error);
 }
 }

 // ===== INICIALIZAÇÃO =====

 // Cria instância global
 window.DataLoader = new DynamicDataLoader();

 // Expõe funções auxiliares
 window.DataLoaderHelpers = {
 populateSelect,
 populateTable,
 updateDashboardCards
 };

  console.log('[DataLoader] ✅ Sistema de carregamento dinâmico inicializado');
  console.log('[DataLoader] 📦 Cache duration:', window.DataLoader.cacheDuration / 1000, 'segundos');

})( window);
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-Events.html -->
<!--============================================================================-->

<!-- JS-Events.html -->
<script>
/**
 * @file JS-Events.html
 * @description Lógica do frontend para a seção de Gestão de Eventos.
 * Adaptado para Google Apps Script usando google.script.run
 * Suporta formulários especializados (Dia Móvel, Reposição, Extracurricular)
 */

const Eventos = {

 activeForm: null,

 /**
 * Inicializa a seção de eventos, carregando dados iniciais.
 */
 init() {
    console.log('[Eventos] Inicializando seção...');
 this.loadEvents();
 this.populateSchoolSelects();
 },

 /**
 * Exibe um formulário de evento específico e oculta os outros.
 * @param {string} formId - O ID do contêiner do formulário a ser exibido.
 */
 showForm(formId) {
 // Oculta o formulário que estava ativo
 if (this.activeForm) {
 const currentActive = document.getElementById(this.activeForm);
      if (currentActive) currentActive.classList.remove('active');
 }

 // Mostra o novo formulário
 const formContainer = document.getElementById(formId);
 if (formContainer) {
      formContainer.classList.add('active');
 this.activeForm = formId;
      formContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
 }
 },

 /**
 * Oculta um formulário de evento.
 * @param {string} formId - O ID do contêiner do formulário a ser ocultado.
 */
 hideForm(formId) {
 const formContainer = document.getElementById(formId);
 if (formContainer) {
      formContainer.classList.remove('active');
 if (this.activeForm === formId) {
 this.activeForm = null;
 }
 }
 },

 /**
 * Manipula o envio do formulário de Dia Móvel/Feriado.
 * @param {Event} event - O evento de submit do formulário.
 */
 async handleHolidaySubmit(event) {
 event.preventDefault();
 const formData = new FormData(event.target);
 const eventData = Object.fromEntries(formData.entries());

 // Mapeia os dados para o formato esperado pelo backend
 const payload = {
      eventType: 'DIA_MOVEL',
 title: `Dia Móvel/Feriado - ${eventData.description}`,
 description: eventData.description,
 startDate: eventData.holidayDate,
 endDate: eventData.holidayDate,
 schoolName: eventData.schoolName,
      status: 'Agendado'
 };

    console.log('[Eventos] Enviando Dia Móvel:', payload);

    const submitButton = event.target.querySelector('button[type="submit"]');
 const originalHTML = submitButton.innerHTML;
 submitButton.disabled = true;
    submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvando...';

 try {
      const result = await this.callBackend('createEvent', payload);

 if (result && result.success) {
        this.showToast('Dia Móvel registrado com sucesso!', 'success');
 event.target.reset();
        this.hideForm('holiday-form-container');
 this.loadEvents(); // Recarrega a lista
 } else {
        throw new Error(result.error || 'Erro ao registrar evento');
 }
 } catch (error) {
      console.error('[Eventos] Erro:', error);
      this.showToast(`Erro ao salvar: ${error.message}`, 'error');
 } finally {
 submitButton.disabled = false;
 submitButton.innerHTML = originalHTML;
 }
 },

 /**
 * Manipula o envio do formulário de Reposição.
 * @param {Event} event - O evento de submit do formulário.
 */
 async handleMakeupSubmit(event) {
 event.preventDefault();
 const formData = new FormData(event.target);
 const eventData = Object.fromEntries(formData.entries());

 const payload = {
      eventType: 'REPOSICAO',
 title: `Reposição - ${eventData.schoolName}`,
 description: eventData.reason,
 startDate: eventData.newDate,
 endDate: eventData.newDate,
 schoolName: eventData.schoolName,
 originalDate: eventData.originalDate,
 time: eventData.time,
      status: 'Agendado'
 };

    console.log('[Eventos] Enviando Reposição:', payload);

    const submitButton = event.target.querySelector('button[type="submit"]');
 const originalHTML = submitButton.innerHTML;
 submitButton.disabled = true;
    submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvando...';

 try {
      const result = await this.callBackend('createEvent', payload);

 if (result && result.success) {
        this.showToast('Reposição agendada com sucesso!', 'success');
 event.target.reset();
        this.hideForm('makeup-form-container');
 this.loadEvents();
 } else {
        throw new Error(result.error || 'Erro ao agendar reposição');
 }
 } catch (error) {
      console.error('[Eventos] Erro:', error);
      this.showToast(`Erro ao salvar: ${error.message}`, 'error');
 } finally {
 submitButton.disabled = false;
 submitButton.innerHTML = originalHTML;
 }
 },

 /**
 * Manipula o envio do formulário de Atividade Extracurricular.
 * @param {Event} event - O evento de submit do formulário.
 */
 async handleExtracurricularSubmit(event) {
 event.preventDefault();
 const formData = new FormData(event.target);
 const eventData = Object.fromEntries(formData.entries());

 const payload = {
      eventType: 'EXTRACURRICULAR',
 title: eventData.activityTitle,
 description: eventData.description || `Atividade do tipo: ${eventData.activityType}`,
 startDate: eventData.activityDate,
 endDate: eventData.activityDate,
 schoolName: eventData.schoolName,
 activityType: eventData.activityType,
 activityTime: eventData.activityTime,
      status: 'Agendado'
 };

    console.log('[Eventos] Enviando Atividade Extracurricular:', payload);

    const submitButton = event.target.querySelector('button[type="submit"]');
 const originalHTML = submitButton.innerHTML;
 submitButton.disabled = true;
    submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvando...';

 try {
      const result = await this.callBackend('createEvent', payload);

 if (result && result.success) {
        this.showToast('Atividade registrada com sucesso!', 'success');
 event.target.reset();
        this.hideForm('extracurricular-form-container');
 this.loadEvents();
 } else {
        throw new Error(result.error || 'Erro ao registrar atividade');
 }
 } catch (error) {
      console.error('[Eventos] Erro:', error);
      this.showToast(`Erro ao salvar: ${error.message}`, 'error');
 } finally {
 submitButton.disabled = false;
 submitButton.innerHTML = originalHTML;
 }
 },

 /**
 * Carrega e exibe a lista de eventos.
 */
 async loadEvents() {
    const listContainer = document.getElementById('events-list');
 if (!listContainer) return;

 listContainer.innerHTML = `
      <div class="loading-placeholder">
        <i class="fas fa-spinner fa-spin"></i>
 <p>Carregando eventos...</p>
 </div>
 `;

 try {
      const result = await this.callBackend('getEvents', {});

 if (result && result.success && result.data && result.data.length > 0) {
 listContainer.innerHTML = this.renderEventsList(result.data);
 } else {
 listContainer.innerHTML = `
          <div class="empty-state">
            <i class="fas fa-calendar-day"></i>
 <p>Nenhum evento registrado para o período.</p>
 </div>
 `;
 }
 } catch (error) {
      console.error('[Eventos] Erro ao carregar eventos:', error);
 listContainer.innerHTML = `
        <div class="empty-state">
          <i class="fas fa-exclamation-triangle"></i>
 <p>Erro ao carregar eventos: ${error.message}</p>
 </div>
 `;
 }
 },

 /**
 * Renderiza a lista de eventos em HTML.
 * @param {Array} events - Array de eventos.
 * @returns {string} HTML renderizado.
 */
 renderEventsList(events) {
    let html = '<div class="events-list-items">';

 events.forEach(event => {
      const eventDate = this.formatDate(event['Data Início'] || event.startDate || event['Data de Início']);
      const eventType = this.getEventTypeLabel(event['Tipo de Evento'] || event.eventType || event.Tipo);
      const eventStatus = event.Status || 'Agendado';
      const eventTitle = event.Título || event.title || event.Titulo || 'Sem título';
      const eventDesc = event.Descrição || event.description || event.Descricao || '';
      const eventSchool = event.Escola || event.schoolName || 'N/A';

 html += `
        <div class="event-item">
          <div class="event-item-header">
            <span class="event-type-badge badge-${this.getEventTypeClass(event['Tipo de Evento'] || event.eventType)}">${eventType}</span>
            <span class="event-status-badge status-${eventStatus.toLowerCase().replace(/\s+/g, '-')}">${eventStatus}</span>
 </div>
          <div class="event-item-body">
            <h4 class="event-item-title">${eventTitle}</h4>
            <p class="event-item-description">${eventDesc}</p>
            <div class="event-item-details">
              <div class="event-item-detail">
                <i class="fas fa-calendar"></i>
 <span>${eventDate}</span>
 </div>
              <div class="event-item-detail">
                <i class="fas fa-school"></i>
 <span>${eventSchool}</span>
 </div>
 </div>
 </div>
 </div>
 `;
 });

    html += '</div>';
 return html;
 },

 /**
 * Popula os selects de escola nos formulários.
 */
 async populateSchoolSelects() {
    const schoolSelects = document.querySelectorAll('#holiday-school, #makeup-school, #extracurricular-school');

 try {
 // Tenta buscar escolas do backend
      const result = await this.callBackend('getSchools', {});

 let schools = [];
 if (result && result.success && result.data) {
 schools = result.data;
 } else {
 // Fallback para dados simulados
 schools = [
          'CEF 01 Planaltina',
          'CED 03 Sobradinho',
          'EC 316 Norte',
          'CEF 02 Brazlândia',
          'CED 01 Taguatinga'
 ];
 }

 schoolSelects.forEach(select => {
        // Limpa opções existentes exceto a primeira (placeholder) e "TODAS"
 const existingOptions = Array.from(select.options);
 existingOptions.forEach((option, index) => {
          if (index > 0 && option.value !== 'TODAS') {
 option.remove();
 }
 });

 // Adiciona as escolas
 schools.forEach(school => {
          const schoolName = typeof school === 'object' ? (school.nome || school.Nome || school.name) : school;
          const option = document.createElement('option');
 option.value = schoolName;
 option.textContent = schoolName;
 select.appendChild(option);
 });
 });
 } catch (error) {
      console.error('[Eventos] Erro ao popular escolas:', error);
 // Usar dados padrão em caso de erro
      const defaultSchools = ['CEF 01 Planaltina', 'CED 03 Sobradinho', 'EC 316 Norte'];
 schoolSelects.forEach(select => {
 defaultSchools.forEach(school => {
          const option = document.createElement('option');
 option.value = school;
 option.textContent = school;
 select.appendChild(option);
 });
 });
 }
 },

 /**
 * Função auxiliar para chamar o backend via google.script.run.
 * @param {string} functionName - Nome da função no EventService.
 * @param {object} params - Parâmetros a serem passados.
 * @returns {Promise} Promessa com o resultado.
 */
 callBackend(functionName, params) {
 return new Promise((resolve, reject) => {
      if (typeof google !== 'undefined' && google.script && google.script.run) {
 google.script.run
 .withSuccessHandler(resolve)
 .withFailureHandler(reject)
 [functionName](params);
 } else {
 // Modo de desenvolvimento/simulação
        console.warn('[Eventos] google.script.run não disponível. Usando modo simulação.');
 setTimeout(() => {
          if (functionName === 'getEvents') {
 resolve({ success: true, data: [] });
          } else if (functionName === 'getSchools') {
            resolve({ success: true, data: ['CEF 01 Planaltina', 'CED 03 Sobradinho', 'EC 316 Norte'] });
 } else {
            resolve({ success: true, message: 'Simulação de sucesso' });
 }
 }, 500);
 }
 });
 },

 /**
 * Exibe uma notificação toast.
 * @param {string} message - Mensagem a exibir.
 * @param {string} type - Tipo: success, error, warning, info.
 */
  showToast(message, type = 'info') {
    if (typeof ToastManager !== 'undefined') {
 ToastManager.show(message, type);
    } else if (typeof showToast === 'function') {
 showToast(message, type);
 } else {
 console.log(`[Toast ${type.toUpperCase()}] ${message}`);
 alert(message);
 }
 },

 /**
 * Formata uma data para exibição.
 * @param {Date|string} date - Data a ser formatada.
 * @returns {string} Data formatada.
 */
 formatDate(date) {
    if (!date) return 'N/A';
 try {
 const d = new Date(date);
      if (isNaN(d.getTime())) return 'Data inválida';
      return d.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });
 } catch (e) {
      return 'Data inválida';
 }
 },

 /**
 * Retorna o label do tipo de evento.
 * @param {string} eventType - Tipo do evento.
 * @returns {string} Label formatado.
 */
 getEventTypeLabel(eventType) {
 const labels = {
      'DIA_MOVEL': 'Dia Móvel/Feriado',
      'REPOSICAO': 'Reposição',
      'EXTRACURRICULAR': 'Atividade Extracurricular',
      'Passeio': 'Passeio',
      'Reunião': 'Reunião',
      'Manutenção Programada': 'Manutenção'
 };
    return labels[eventType] || eventType || 'Evento';
 },

 /**
 * Retorna a classe CSS para o tipo de evento.
 * @param {string} eventType - Tipo do evento.
 * @returns {string} Classe CSS.
 */
 getEventTypeClass(eventType) {
 const classes = {
      'DIA_MOVEL': 'holiday',
      'REPOSICAO': 'makeup',
      'EXTRACURRICULAR': 'extracurricular',
      'Passeio': 'trip',
      'Reunião': 'meeting'
 };
    return classes[eventType] || 'default';
 }
};

// Disponibiliza globalmente para uso nos onclick do HTML
window.Eventos = Eventos;

// Inicializa o módulo quando o DOM estiver pronto ou seção visível
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    const eventosSection = document.getElementById('eventos-section');
    if (eventosSection && !eventosSection.classList.contains('hidden')) {
 Eventos.init();
 }
 });
} else {
 // DOM já carregado, verifica se seção está visível
  const eventosSection = document.getElementById('eventos-section');
  if (eventosSection && !eventosSection.classList.contains('hidden')) {
 Eventos.init();
 }
}
</script>

<style>
/* Estilos específicos para a lista de eventos */
.events-list-items {
 display: grid;
 grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
 gap: var(--space-4, 1rem);
 padding: var(--space-2, 0.5rem);
}

.event-item {
 background: var(--surface, #fff);
 border: 1px solid var(--outline-variant, #e0e0e0);
 border-radius: var(--radius-md, 8px);
 padding: var(--space-4, 1rem);
 transition: all 0.2s ease;
}

.event-item:hover {
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
 transform: translateY(-2px);
}

.event-item-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 margin-bottom: var(--space-3, 0.75rem);
 gap: var(--space-2, 0.5rem);
 flex-wrap: wrap;
}

.event-type-badge {
 display: inline-block;
 padding: 0.25rem 0.75rem;
 border-radius: var(--radius-sm, 4px);
 font-size: 0.75rem;
 font-weight: 600;
 text-transform: uppercase;
 letter-spacing: 0.5px;
}

.event-type-badge.badge-holiday {
 background: var(--md-sys-color-warning-container);
 color: #e65100;
}

.event-type-badge.badge-makeup {
 background: var(--md-sys-color-primary-container);
 color: #1565c0;
}

.event-type-badge.badge-extracurricular {
 background: #f3e5f5;
 color: var(--md-sys-color-on-tertiary);
}

.event-type-badge.badge-trip {
 background: var(--md-sys-color-success-container);
 color: var(--md-sys-color-success-container);
}

.event-type-badge.badge-default {
 background: #f5f5f5;
 color: #616161;
}

.event-status-badge {
 display: inline-block;
 padding: 0.25rem 0.75rem;
 border-radius: var(--radius-sm, 4px);
 font-size: 0.75rem;
 font-weight: 600;
}

.event-status-badge.status-agendado {
 background: var(--md-sys-color-warning-container);
 color: var(--md-sys-color-warning);
}

.event-status-badge.status-confirmado {
 background: var(--md-sys-color-success-container);
 color: var(--md-sys-color-success-container);
}

.event-status-badge.status-cancelado {
 background: #ffebee;
 color: var(--md-sys-color-error);
}

.event-status-badge.status-concluído,
.event-status-badge.status-concluido {
 background: #e0e0e0;
 color: #424242;
}

.event-item-body {
 display: flex;
 flex-direction: column;
 gap: var(--space-2, 0.5rem);
}

.event-item-title {
 margin: 0;
 font-size: 1.1rem;
 font-weight: 600;
 color: var(--on-surface, #1f2937);
 line-height: 1.4;
}

.event-item-description {
 margin: 0;
 font-size: 0.9rem;
 color: var(--on-surface-variant, #64748b);
 line-height: 1.5;
 display: -webkit-box;
 -webkit-line-clamp: 2;
 line-clamp: 2;
 -webkit-box-orient: vertical;
 overflow: hidden;
}

.event-item-details {
 display: flex;
 flex-direction: column;
 gap: var(--space-2, 0.5rem);
 margin-top: var(--space-2, 0.5rem);
 padding-top: var(--space-2, 0.5rem);
 border-top: 1px solid var(--outline-variant, #e0e0e0);
}

.event-item-detail {
 display: flex;
 align-items: center;
 gap: var(--space-2, 0.5rem);
 font-size: 0.85rem;
 color: var(--on-surface-variant, #64748b);
}

.event-item-detail i {
 width: 16px;
 text-align: center;
 color: var(--primary, var(--md-sys-color-primary));
}

.empty-state {
 text-align: center;
 padding: var(--space-8, 3rem) var(--space-4, 1rem);
 color: var(--on-surface-variant, #64748b);
}

.empty-state i {
 font-size: 3rem;
 margin-bottom: var(--space-4, 1rem);
 opacity: 0.3;
}

.empty-state p {
 margin: 0;
 font-size: 1rem;
}

.loading-placeholder {
 text-align: center;
 padding: var(--space-8, 3rem) var(--space-4, 1rem);
 color: var(--on-surface-variant, #64748b);
}

.loading-placeholder i {
 font-size: 2rem;
 margin-bottom: var(--space-3, 0.75rem);
 color: var(--primary, var(--md-sys-color-primary));
}

.loading-placeholder p {
 margin: 0;
}
</style>

<!--============================================================================-->
<!-- ARQUIVO: JS-FooterActions.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 FOOTER ACTIONS MANAGER
 Gerencia as ações dos botões do rodapé: Tema, Atualização e Backup.
 ============================================================================ */

(function(window) {
    'use strict';

 /**
 * Gerenciador de Tema (Light/Dark)
 */
 const ThemeManager = {
 init() {
            this.toggleButton = document.getElementById('theme-toggle');
 if (!this.toggleButton) return;

            this.toggleButton.addEventListener('click', () => this.toggleTheme());
 this.applyInitialTheme();
            console.log('[ThemeManager] ✅ Gerenciador de tema inicializado.');
 },

 getCurrentTheme() {
            return document.documentElement.getAttribute('data-theme') || 'dark';
 },

 applyInitialTheme() {
            const savedTheme = localStorage.getItem('sigte:theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
 },

 toggleTheme() {
 const currentTheme = this.getCurrentTheme();
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('sigte:theme', newTheme);

            ToastManager.show(`Tema alterado para ${newTheme === 'dark' ? 'Escuro' : 'Claro'}`, 'success', 1500);

 // Dispara um evento para que outros componentes (ex: gráficos) possam se adaptar
            document.dispatchEvent(new CustomEvent('themeChanged', { detail: { theme: newTheme } }));
 }
 };

 /**
 * Gerenciador de Sincronização e Backup
 */
 const DataSyncManager = {
 init() {
            this.updateButton = document.getElementById('update-data-button');
            this.backupButton = document.getElementById('backup-button');

 if (this.updateButton) {
                this.updateButton.addEventListener('click', () => this.refreshCurrentSectionData());
 }

 if (this.backupButton) {
                this.backupButton.addEventListener('click', () => this.triggerBackup());
 }
            console.log('[DataSyncManager] ✅ Gerenciador de dados inicializado.');
 },

 async refreshCurrentSectionData() {
            const activeSection = document.querySelector('.section.active');
 if (!activeSection) {
                ToastManager.show('Nenhuma seção ativa para atualizar.', 'warning');
 return;
 }

            const sectionId = activeSection.id.replace('-section', '');
            const icon = this.updateButton.querySelector('i');

            if (icon) icon.classList.add('fa-spin');
            ToastManager.show('Atualizando dados...', 'info');

 try {
 if (window.CRUDManagerUniversal && CRUDManagerUniversal.instances[sectionId]) {
 await CRUDManagerUniversal.loadData(sectionId);
                } else if (sectionId === 'frequencia' && window.AttendanceManager) {
 // Lógica específica para a seção de frequência
 await window.AttendanceManager.loadInitialData();
                    ToastManager.show('Rotas de frequência recarregadas.', 'info');
 }
 else {
                    console.warn(`[DataSync] Nenhuma ação de atualização definida para a seção '${sectionId}'.`);
 }

                ToastManager.show('Dados atualizados com sucesso!', 'success');
 } catch (error) {
 console.error(`[DataSync] Erro ao atualizar dados da seção ${sectionId}:`, error);
                ToastManager.show('Falha ao atualizar os dados.', 'error');
 } finally {
                if (icon) icon.classList.remove('fa-spin');
 }
 },

 async triggerBackup() {
            if (!confirm('Deseja criar um backup completo da base de dados agora? Esta operação pode levar alguns minutos.')) {
 return;
 }

            const icon = this.backupButton.querySelector('i');
            if (icon) icon.classList.add('fa-spin');
            ToastManager.show('Iniciando processo de backup...', 'info');

 try {
 // Esta função deve existir no seu Code.gs
                const result = await API.run('createBackup');
                ToastManager.show(result.message || 'Backup concluído com sucesso!', 'success');
 } catch (error) {
                console.error('[Backup] Erro ao criar backup:', error);
                ToastManager.show(`Falha no backup: ${error.message}`, 'error');
 } finally {
                if (icon) icon.classList.remove('fa-spin');
 }
 }
 };

 // Inicializa os gerenciadores quando o DOM estiver pronto
    document.addEventListener('DOMContentLoaded', () => {
 ThemeManager.init();
 DataSyncManager.init();
 });

})(window);
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-FormHelpers.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 FORM HELPERS & CALCULATED FIELDS
 Sistema de campos calculados, validações e auto-preenchimento
 ============================================================================ */

(function(window) {
    'use strict';

 /**
 * Gerenciador de Campos Calculados
 * Implementa lógica de cálculos automáticos em formulários
 */
 const CalculatedFieldsManager = {

 /**
 * Configurações de campos calculados por seção
 */
 calculations: {
            'frequencia': [
 {
 // KM Rodados = KM Final - KM Inicial
                    inputs: ['frequencia-km-inicial', 'frequencia-km-final'],
                    output: 'frequencia-km-rodados',
 calculate: (inicial, final) => {
 const kmInicial = parseFloat(inicial) || 0;
 const kmFinal = parseFloat(final) || 0;
                        return kmFinal > kmInicial ? (kmFinal - kmInicial).toFixed(1) : '';
 },
 validate: (result, inicial, final) => {
 if (result < 0) {
                            return 'KM Final deve ser maior que KM Inicial';
 }
 if (result > 500) {
                            return 'KM Rodados parece muito alto. Verifique os valores.';
 }
 return null;
 }
 }
 ],
            'manutencao': [
 {
 // Próximo serviço baseado em KM atual
                    inputs: ['manutencao-km-servico', 'manutencao-intervalo-km'],
                    output: 'manutencao-proximo-km',
 calculate: (kmAtual, intervalo) => {
 const km = parseFloat(kmAtual) || 0;
 const int = parseFloat(intervalo) || 0;
                        return km > 0 && int > 0 ? (km + int).toFixed(0) : '';
 }
 }
 ],
            'utilizacao-frota': [
 {
 // Eficiência de combustível (KM/L)
                    inputs: ['utilizacao-km-rodados', 'utilizacao-combustivel-usado'],
                    output: 'utilizacao-eficiencia',
 calculate: (km, combustivel) => {
 const kmVal = parseFloat(km) || 0;
 const combVal = parseFloat(combustivel) || 0;
                        return combVal > 0 ? (kmVal / combVal).toFixed(2) : '';
 }
 },
 {
 // Taxa de ocupação (%)
                    inputs: ['utilizacao-alunos-transportados', 'utilizacao-capacidade-veiculo'],
                    output: 'utilizacao-taxa-ocupacao',
 calculate: (alunos, capacidade) => {
 const alunosVal = parseFloat(alunos) || 0;
 const capVal = parseFloat(capacidade) || 0;
                        return capVal > 0 ? ((alunosVal / capVal) * 100).toFixed(1) + '%' : '';
 }
 }
 ]
 },

 /**
 * Inicializa campos calculados para uma seção
 */
 init(sectionId) {
 const configs = this.calculations[sectionId];
 if (!configs) return;

 console.log(`[CalculatedFields] Inicializando para: ${sectionId}`);

 configs.forEach(config => {
 config.inputs.forEach(inputId => {
 const input = document.getElementById(inputId);
 if (input) {
                        input.addEventListener('input', () => {
 this.recalculate(config);
 });
                        input.addEventListener('blur', () => {
 this.validateCalculation(config);
 });
 }
 });
 });
 },

 /**
 * Recalcula um campo
 */
 recalculate(config) {
 const values = config.inputs.map(id => {
 const el = document.getElementById(id);
                return el ? el.value : '';
 });

 const result = config.calculate(...values);
 const outputEl = document.getElementById(config.output);

 if (outputEl) {
 outputEl.value = result;
                outputEl.dispatchEvent(new Event('change')); // Trigger outros listeners
 }
 },

 /**
 * Valida um cálculo
 */
 validateCalculation(config) {
 if (!config.validate) return;

 const values = config.inputs.map(id => {
 const el = document.getElementById(id);
                return el ? el.value : '';
 });

 const result = config.calculate(...values);
 const error = config.validate(parseFloat(result), ...values);

 const outputEl = document.getElementById(config.output);
 if (outputEl && error) {
                outputEl.classList.add('is-invalid');

 // Mostra mensagem de erro
                let errorDiv = outputEl.parentElement.querySelector('.form-error-message');
 if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'form-error-message';
 outputEl.parentElement.appendChild(errorDiv);
 }
 errorDiv.textContent = error;
 } else if (outputEl) {
                outputEl.classList.remove('is-invalid');
                const errorDiv = outputEl.parentElement.querySelector('.form-error-message');
                if (errorDiv) errorDiv.textContent = '';
 }
 }
 };

 /**
 * Gerenciador de Auto-Preenchimento
 * Preenche campos automaticamente baseado em seleções
 */
 const AutoFillManager = {

 /**
 * Configurações de auto-preenchimento
 */
 autoFillRules: {
            'frequencia': {
 // Ao selecionar rota, preencher veículo e alunos
                'frequencia-rota': async (value, formId) => {
 if (!value) return;

 try {
                        LoadingManager.show('Carregando dados da rota...');

 // Busca dados da rota
                        const rotaData = await API.run('readRecords', {
                            sheetName: 'Rotas',
 id: value
 });

 if (rotaData && rotaData.Veiculo_ID) {
                            const veiculoSelect = document.getElementById('veiculo_id');
 if (veiculoSelect) {
 veiculoSelect.value = rotaData.Veiculo_ID;
                                veiculoSelect.dispatchEvent(new Event('change'));
 }
 }

 // Carrega alunos da rota
 if (window.AttendanceManager && window.AttendanceManager.loadStudentsForRoute) {
 await window.AttendanceManager.loadStudentsForRoute(value);
 }

 LoadingManager.hide();
 } catch (error) {
                        console.error('[AutoFill] Erro ao carregar dados da rota:', error);
 LoadingManager.hide();
 }
 }
 },
            'alunos': {
 // Ao selecionar rota, preencher pontos de embarque
                'aluno-rota': async (value, formId) => {
 if (!value) return;

 try {
                        const rotaData = await API.run('readRecords', {
                            sheetName: 'Rotas',
 id: value
 });

 if (rotaData && rotaData.Pontos_Parada) {
 // Atualiza select de pontos de embarque
                            const embarqueSelect = document.getElementById('aluno-ponto-embarque');
 if (embarqueSelect) {
                                const pontos = rotaData.Pontos_Parada.split(';');
                                embarqueSelect.innerHTML = '<option value="">Selecione...</option>';
 pontos.forEach(ponto => {
                                    const option = document.createElement('option');
 option.value = ponto;
 option.textContent = ponto;
 embarqueSelect.appendChild(option);
 });
 }
 }
 } catch (error) {
                        console.error('[AutoFill] Erro ao carregar pontos da rota:', error);
 }
 }
 }
 },

 /**
 * Inicializa auto-preenchimento para um formulário
 */
 init(sectionId, formId) {
 const rules = this.autoFillRules[sectionId];
 if (!rules) return;

 console.log(`[AutoFill] Inicializando para: ${sectionId}`);

 Object.keys(rules).forEach(fieldId => {
 const field = document.getElementById(fieldId);
 if (field) {
                    field.addEventListener('change', (e) => {
 const handler = rules[fieldId];
 if (handler) {
 handler(e.target.value, formId);
 }
 });
 }
 });
 }
 };

 /**
 * Validador de Campos Customizados
 * Validações específicas por tipo de campo
 */
 const CustomValidator = {

 /**
 * Valida CPF
 */
 validateCPF(cpf) {
            cpf = cpf.replace(/[^\d]/g, '');

 if (cpf.length !== 11) return false;
 if (/^(\d)\1{10}$/.test(cpf)) return false; // Sequência repetida

 // Valida dígitos verificadores
 let sum = 0;
 for (let i = 0; i < 9; i++) {
 sum += parseInt(cpf.charAt(i)) * (10 - i);
 }
 let digit = 11 - (sum % 11);
 if (digit >= 10) digit = 0;
 if (digit !== parseInt(cpf.charAt(9))) return false;

 sum = 0;
 for (let i = 0; i < 10; i++) {
 sum += parseInt(cpf.charAt(i)) * (11 - i);
 }
 digit = 11 - (sum % 11);
 if (digit >= 10) digit = 0;
 if (digit !== parseInt(cpf.charAt(10))) return false;

 return true;
 },

 /**
 * Valida CNPJ
 */
 validateCNPJ(cnpj) {
            cnpj = cnpj.replace(/[^\d]/g, '');

 if (cnpj.length !== 14) return false;
 if (/^(\d)\1{13}$/.test(cnpj)) return false;

 return true; // Simplificado - adicionar validação completa se necessário
 },

 /**
 * Valida Placa de Veículo (Mercosul ou antiga)
 */
 validatePlaca(placa) {
            placa = placa.toUpperCase().replace(/[^A-Z0-9]/g, '');

 // Formato Mercosul: ABC1D23
 const mercosul = /^[A-Z]{3}[0-9][A-Z0-9][0-9]{2}$/;
 // Formato antigo: ABC1234
 const antiga = /^[A-Z]{3}[0-9]{4}$/;

 return mercosul.test(placa) || antiga.test(placa);
 },

 /**
 * Valida Telefone Brasileiro
 */
 validatePhone(phone) {
            const cleaned = phone.replace(/\D/g, '');

 // 8-11 dígitos (com ou sem DDD)
 if (cleaned.length < 8 || cleaned.length > 11) return false;

 // Se tiver 11 dígitos, o 3º deve ser 9 (celular)
            if (cleaned.length === 11 && cleaned.charAt(2) !== '9') return false;

 return true;
 },

 /**
 * Aplica validação customizada a um campo
 */
 applyValidation(fieldId, validationType) {
 const field = document.getElementById(fieldId);
 if (!field) return;

            field.addEventListener('blur', (e) => {
 const value = e.target.value;
 if (!value) return; // Não valida se estiver vazio

 let isValid = false;
                let errorMsg = '';

 switch(validationType) {
                    case 'cpf':
 isValid = this.validateCPF(value);
                        errorMsg = 'CPF inválido';
 break;
                    case 'cnpj':
 isValid = this.validateCNPJ(value);
                        errorMsg = 'CNPJ inválido';
 break;
                    case 'placa':
 isValid = this.validatePlaca(value);
                        errorMsg = 'Placa inválida (use formato ABC-1234 ou ABC1D23)';
 break;
                    case 'phone':
 isValid = this.validatePhone(value);
                        errorMsg = 'Telefone inválido';
 break;
 }

 if (!isValid) {
                    field.classList.add('is-invalid');
                    let errorDiv = field.parentElement.querySelector('.form-error-message');
 if (!errorDiv) {
                        errorDiv = document.createElement('div');
                        errorDiv.className = 'form-error-message';
 field.parentElement.appendChild(errorDiv);
 }
 errorDiv.textContent = errorMsg;
 } else {
                    field.classList.remove('is-invalid');
                    const errorDiv = field.parentElement.querySelector('.form-error-message');
                    if (errorDiv) errorDiv.textContent = '';
 }
 });
 }
 };

 /**
 * Máscaras de Input
 * Formata campos enquanto o usuário digita
 */
 const InputMasksManager = {

 masks: {
            'cpf': (value) => {
                value = value.replace(/\D/g, '');
                value = value.replace(/(\d{3})(\d)/, '$1.$2');
                value = value.replace(/(\d{3})(\d)/, '$1.$2');
                value = value.replace(/(\d{3})(\d{1,2})$/, '$1-$2');
 return value;
 },
            'cnpj': (value) => {
                value = value.replace(/\D/g, '');
                value = value.replace(/^(\d{2})(\d)/, '$1.$2');
                value = value.replace(/^(\d{2})\.(\d{3})(\d)/, '$1.$2.$3');
                value = value.replace(/\.(\d{3})(\d)/, '.$1/$2');
                value = value.replace(/(\d{4})(\d)/, '$1-$2');
 return value;
 },
            'phone': (value) => {
                value = value.replace(/\D/g, '');
 if (value.length <= 10) {
                    value = value.replace(/^(\d{2})(\d)/g, '($1) $2');
                    value = value.replace(/(\d)(\d{4})$/, '$1-$2');
 } else {
                    value = value.replace(/^(\d{2})(\d)/g, '($1) $2');
                    value = value.replace(/(\d)(\d{4})$/, '$1-$2');
 }
 return value;
 },
            'cep': (value) => {
                value = value.replace(/\D/g, '');
                value = value.replace(/^(\d{5})(\d)/, '$1-$2');
 return value;
 },
            'placa': (value) => {
                value = value.toUpperCase().replace(/[^A-Z0-9]/g, '');
 return value;
 }
 },

 /**
 * Aplica máscara a um campo
 */
 applyMask(fieldId, maskType) {
 const field = document.getElementById(fieldId);
 if (!field || !this.masks[maskType]) return;

            field.addEventListener('input', (e) => {
 const cursorPosition = e.target.selectionStart;
 const oldLength = e.target.value.length;

 e.target.value = this.masks[maskType](e.target.value);

 const newLength = e.target.value.length;
 const diff = newLength - oldLength;

 // Ajusta posição do cursor
                e.target.setSelectionRange(cursorPosition + diff, cursorPosition + diff);
            });
        }
    };

    /**
     * Gerenciador de População Automática de Dropdowns
     * Popula selects automaticamente usando DataLoader
     */
    const DropdownPopulator = {

        /**
         * Configurações de dropdowns por planilha
         */
        configs: {
            'Rotas': {
                valueField: 'ID',
                labelFields: ['Codigo', 'Nome_Rota'],
                labelTemplate: (row) => `${row.Codigo} - ${row.Nome_Rota}`,
                filters: { Status: 'Ativa' },
                sortBy: 'Codigo'
            },
            'Veiculos': {
                valueField: 'ID',
                labelFields: ['Placa', 'Modelo'],
                labelTemplate: (row) => `${row.Placa} - ${row.Modelo}`,
                filters: { Status: 'Operacional' },
                sortBy: 'Placa'
            },
            'Pessoal_Motoristas': {
                sheetName: 'Pessoal',
                valueField: 'ID',
                labelFields: ['Nome_Completo'],
                labelTemplate: (row) => row.Nome_Completo,
                filters: { Cargo: 'Motorista', Status_Contrato: 'ATIVO' },
                sortBy: 'Nome_Completo'
            },
            'Pessoal_Monitores': {
                sheetName: 'Pessoal',
                valueField: 'ID',
                labelFields: ['Nome_Completo'],
                labelTemplate: (row) => row.Nome_Completo,
                filters: { Cargo: 'Monitor', Status_Contrato: 'ATIVO' },
                sortBy: 'Nome_Completo'
            }
        },

        /**
         * Popula um dropdown
         * @param {string} selectId - ID do elemento select
         * @param {string} configKey - Chave da configuração
         * @param {Object} additionalFilters - Filtros adicionais opcionais
         */
        async populate(selectId, configKey, additionalFilters = {}) {
            const select = document.getElementById(selectId);
            if (!select) {
                console.error(`[DropdownPopulator] Select não encontrado: ${selectId}`);
                return;
            }

            const config = this.configs[configKey];
            if (!config) {
                console.error(`[DropdownPopulator] Configuração não encontrada: ${configKey}`);
                return;
            }

            try {
                // Mostra estado de carregamento
                select.disabled = true;
                select.innerHTML = '<option value="">Carregando...</option>';

                // Carrega dados
                const sheetName = config.sheetName || configKey;
                const filters = { ...config.filters, ...additionalFilters };
                const data = await window.DataLoader.load(sheetName, filters, false);

                // Limpa e adiciona opção padrão
                select.innerHTML = '<option value="">Selecione...</option>';

                // Ordena dados se configurado
                if (config.sortBy) {
                    data.sort((a, b) => {
                        const valA = a[config.sortBy] || '';
                        const valB = b[config.sortBy] || '';
                        return valA.toString().localeCompare(valB.toString());
                    });
                }

                // Adiciona opções
                data.forEach(row => {
                    const option = document.createElement('option');
                    option.value = row[config.valueField];
                    option.textContent = config.labelTemplate(row);
                    // Armazena dados completos no option para uso posterior
                    option.dataset.rowData = JSON.stringify(row);
                    select.appendChild(option);
                });

                console.log(`[DropdownPopulator] ${selectId}: ${data.length} opções carregadas`);

                // Auto-seleciona se houver apenas 1 opção
                if (data.length === 1) {
                    select.value = data[0][config.valueField];
                    select.dispatchEvent(new Event('change'));
                    if (window.ToastManager) {
                        window.ToastManager.show(
                            `${configKey} selecionado automaticamente`,
                            'info'
                        );
                    }
                }

            } catch (error) {
                console.error(`[DropdownPopulator] Erro ao carregar ${configKey}:`, error);
                select.innerHTML = '<option value="">Erro ao carregar</option>';
                if (window.ToastManager) {
                    window.ToastManager.show(`Erro ao carregar ${configKey}`, 'error');
                }
            } finally {
                select.disabled = false;
            }
        },

        /**
         * Popula múltiplos dropdowns em paralelo
         * @param {Array<{selectId: string, configKey: string, filters?: Object}>} configs
         */
        async populateMultiple(configs) {
            const promises = configs.map(({ selectId, configKey, filters }) =>
                this.populate(selectId, configKey, filters)
            );
            await Promise.allSettled(promises);
        },

        /**
         * Obtém dados completos da opção selecionada
         * @param {string} selectId - ID do select
         * @returns {Object|null}
         */
        getSelectedData(selectId) {
            const select = document.getElementById(selectId);
            if (!select || !select.value) return null;

            const selectedOption = select.options[select.selectedIndex];
            if (!selectedOption || !selectedOption.dataset.rowData) return null;

            try {
                return JSON.parse(selectedOption.dataset.rowData);
            } catch (error) {
                console.error('[DropdownPopulator] Erro ao parsear dados da opção:', error);
                return null;
            }
        }
    };

    /**
     * Gerenciador Universal de Submit de Formulários
     * Padroniza o fluxo de criação/edição de registros
     */
    const UniversalFormSubmit = {

        /**
         * Configura submit de um formulário
         * @param {string} formId - ID do formulário
         * @param {string} sheetName - Nome da planilha destino
         * @param {Object} options - Opções adicionais
         */
        setup(formId, sheetName, options = {}) {
            const form = document.getElementById(formId);
            if (!form) {
                console.error(`[UniversalFormSubmit] Formulário não encontrado: ${formId}`);
                return;
            }

            const defaultOptions = {
                onSuccess: null,
                onError: null,
                beforeSubmit: null,
                afterSubmit: null,
                successMessage: 'Registro salvo com sucesso!',
                redirectAfterSuccess: false,
                clearFormAfterSuccess: true,
                validateBeforeSubmit: true
            };

            const config = { ...defaultOptions, ...options };

            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                await this.handleSubmit(form, sheetName, config);
            });

            console.log(`[UniversalFormSubmit] Configurado: ${formId} → ${sheetName}`);
        },

        /**
         * Processa submit do formulário
         */
        async handleSubmit(form, sheetName, config) {
            // Validação básica
            if (config.validateBeforeSubmit && !form.checkValidity()) {
                if (window.ToastManager) {
                    window.ToastManager.show(
                        'Por favor, preencha todos os campos obrigatórios.',
                        'warning'
                    );
                }
                form.reportValidity();
                return;
            }

            // Callback antes do submit
            if (config.beforeSubmit) {
                const shouldContinue = await config.beforeSubmit(form);
                if (shouldContinue === false) return;
            }

            // Captura dados do formulário
            const formData = new FormData(form);
            const data = Object.fromEntries(formData.entries());

            // Detecta modo edição
            const isEditMode = form.dataset.editingId;
            if (isEditMode) {
                data.ID = form.dataset.editingId;
            }

            // Adiciona timestamps
            if (!isEditMode) {
                data.Timestamp_Criacao = new Date().toISOString();
            }
            data.Timestamp_Atualizacao = new Date().toISOString();

            // Loading state
            const submitButton = form.querySelector('button[type="submit"]');
            if (submitButton && window.LoadingManager) {
                window.LoadingManager.showButtonLoading(submitButton);
            }

            try {
                // Chama backend
                const method = isEditMode ? 'updateRecord' : 'createRecord';
                const result = await window.API.run(method, {
                    sheetName: sheetName,
                    data: data
                });

                if (result.success) {
                    // Toast de sucesso
                    if (window.ToastManager) {
                        window.ToastManager.show(config.successMessage, 'success');
                    }

                    // Callback de sucesso
                    if (config.onSuccess) {
                        await config.onSuccess(result);
                    }

                    // Limpa formulário
                    if (config.clearFormAfterSuccess) {
                        form.reset();
                        delete form.dataset.editingId;
                        
                        // Reset botão para modo criação
                        if (submitButton) {
                            submitButton.innerHTML = '<i class="fas fa-save"></i> Salvar';
                        }
                    }

                    // Dispara evento para outros componentes
                    window.dispatchEvent(new CustomEvent('recordSaved', {
                        detail: { sheetName, data: result.data, isEdit: !!isEditMode }
                    }));

                    // Invalida cache
                    if (window.DataLoader) {
                        window.DataLoader.invalidateCache(sheetName);
                    }

                    // Redireciona se configurado
                    if (config.redirectAfterSuccess && window.NavigationManager) {
                        setTimeout(() => {
                            window.NavigationManager.navigate(config.redirectAfterSuccess);
                        }, 1000);
                    }

                } else {
                    throw new Error(result.error || 'Erro ao salvar registro');
                }

            } catch (error) {
                console.error('[UniversalFormSubmit] Erro:', error);
                
                if (window.ToastManager) {
                    window.ToastManager.show(
                        `Erro ao salvar: ${error.message}`,
                        'error'
                    );
                }

                // Callback de erro
                if (config.onError) {
                    await config.onError(error);
                }

            } finally {
                // Remove loading state
                if (submitButton && window.LoadingManager) {
                    window.LoadingManager.hideButtonLoading(submitButton);
                }

                // Callback após submit
                if (config.afterSubmit) {
                    await config.afterSubmit();
                }
            }
        },

        /**
         * Preenche formulário com dados para edição
         * @param {string} formId - ID do formulário
         * @param {Object} data - Dados do registro
         */
        fillForm(formId, data) {
            const form = document.getElementById(formId);
            if (!form) return;

            // Marca como modo edição
            form.dataset.editingId = data.ID || data.id;

            // Preenche campos
            Object.keys(data).forEach(key => {
                const field = form.querySelector(`[name="${key}"]`);
                if (field) {
                    if (field.type === 'checkbox') {
                        field.checked = data[key] === 'Sim' || data[key] === true;
                    } else if (field.type === 'radio') {
                        const radio = form.querySelector(`[name="${key}"][value="${data[key]}"]`);
                        if (radio) radio.checked = true;
                    } else {
                        field.value = data[key] || '';
                    }
                    // Dispara evento change para triggers
                    field.dispatchEvent(new Event('change'));
                }
            });

            // Atualiza botão de submit
            const submitButton = form.querySelector('button[type="submit"]');
            if (submitButton) {
                submitButton.innerHTML = '<i class="fas fa-save"></i> Atualizar';
            }

            console.log(`[UniversalFormSubmit] Formulário preenchido para edição: ${data.ID}`);
        }
    };

    // Exporta para escopo global
    window.CalculatedFieldsManager = CalculatedFieldsManager;
    window.AutoFillManager = AutoFillManager;
    window.CustomValidator = CustomValidator;
    window.InputMasksManager = InputMasksManager;
    window.DropdownPopulator = DropdownPopulator;
    window.UniversalFormSubmit = UniversalFormSubmit;

    console.log('[FormHelpers] Módulo carregado com DropdownPopulator e UniversalFormSubmit');

})(window);
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-Logger.html -->
<!--============================================================================-->

<script>
/**
 * ============================================================================
 * LOGGER CONDICIONAL - Sistema de Logging para Produção
 * ============================================================================
 *
 * Gerencia logs de forma inteligente baseado no ambiente
 * Versão: 1.0
 * Data: 2025-10-16
 * ============================================================================
 */

(function(window) {
  'use strict';

 /**
 * Detecta ambiente de execução
   * @returns {string} 'production' ou 'development'
 */
 function detectEnvironment() {
 // Se estiver no domínio do Google Apps Script publicado = produção
 const hostname = window.location.hostname;

    if (hostname.includes('script.google.com') ||
        hostname.includes('script.googleusercontent.com')) {
      return 'production';
 }

 // Modo de desenvolvimento (testando localmente ou via Apps Script Editor)
    return 'development';
 }

 /**
 * Logger inteligente que desabilita logs em produção
 */
 const Logger = {

 environment: detectEnvironment(),

 // Flag para forçar logs (debug remoto em produção)
 forceEnable: false,

 /**
 * Verifica se deve logar
 */
 shouldLog() {
      return this.forceEnable || this.environment === 'development';
 },

 /**
 * Log de informação
 */
 log(...args) {
 if (this.shouldLog()) {
 console.log(...args);
 }
 },

 /**
 * Log de informação (alias)
 */
 info(...args) {
 if (this.shouldLog()) {
 console.info(...args);
 }
 },

 /**
 * Log de warning (sempre mostra)
 */
 warn(...args) {
 console.warn(...args);
 },

 /**
 * Log de erro (sempre mostra)
 */
 error(...args) {
 console.error(...args);
 },

 /**
 * Log de debug (apenas em desenvolvimento)
 */
 debug(...args) {
 if (this.shouldLog()) {
 console.debug(...args);
 }
 },

 /**
 * Grupo de logs
 */
 group(label) {
 if (this.shouldLog() && console.group) {
 console.group(label);
 }
 },

 /**
 * Grupo de logs colapsado
 */
 groupCollapsed(label) {
 if (this.shouldLog() && console.groupCollapsed) {
 console.groupCollapsed(label);
 }
 },

 /**
 * Fecha grupo de logs
 */
 groupEnd() {
 if (this.shouldLog() && console.groupEnd) {
 console.groupEnd();
 }
 },

 /**
 * Tabela (apenas desenvolvimento)
 */
 table(data) {
 if (this.shouldLog() && console.table) {
 console.table(data);
 }
 },

 /**
 * Tempo (performance)
 */
 time(label) {
 if (this.shouldLog() && console.time) {
 console.time(label);
 }
 },

 /**
 * Fim do tempo
 */
 timeEnd(label) {
 if (this.shouldLog() && console.timeEnd) {
 console.timeEnd(label);
 }
 },

 /**
 * Habilita logs remotos em produção (para debug)
 * Usar apenas quando necessário!
 */
 enableRemoteDebug() {
 this.forceEnable = true;
      console.warn('⚠️ Remote debug ENABLED. Logs visíveis em produção!');
 },

 /**
 * Desabilita logs remotos
 */
 disableRemoteDebug() {
 this.forceEnable = false;
      if (this.environment === 'production') {
        console.info('✅ Remote debug DISABLED. Logs silenciados em produção.');
 }
 },

 /**
 * Informações do ambiente
 */
 getEnvironmentInfo() {
 return {
 environment: this.environment,
 forceEnabled: this.forceEnable,
 hostname: window.location.hostname,
 userAgent: navigator.userAgent,
 timestamp: new Date().toISOString()
 };
 }
 };

 // Exponha globalmente
 window.Logger = Logger;

 // Substitui console nativo em produção
  if (Logger.environment === 'production' && !Logger.forceEnable) {
 const noop = () => {};
 window.console = {
 ...console,
 log: noop,
 debug: noop,
 info: noop,
 // Mantém warn e error
 warn: console.warn.bind(console),
 error: console.error.bind(console)
 };
 }

 // Log inicial
 if (Logger.shouldLog()) {
 console.log(`[Logger] Ambiente: ${Logger.environment}`);
    console.log(`[Logger] Logs ${Logger.environment === 'production' ? 'DESABILITADOS' : 'HABILITADOS'}`);
 }

})(window);
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-MenuToggle.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 MENU TOGGLE - Alterna entre ícones-apenas e ícones+títulos
 ============================================================================ */

(function(window) {
    'use strict';

 const MenuToggleManager = {
 init() {
            this.toggleButton = document.getElementById('menu-toggle-btn');
            this.navContainer = document.getElementById('horizontal-nav');

 if (!this.toggleButton || !this.navContainer) {
                console.error('[MenuToggleManager] Elementos não encontrados');
 return;
 }

 // Estado inicial: retraído (apenas ícones)
 this.isExpanded = false;
            this.navContainer.classList.add('collapsed');

 // Event listener para o botão
            this.toggleButton.addEventListener('click', () => this.toggle());

            console.log('[MenuToggleManager] ✅ Gerenciador de menu toggle inicializado.');
 },

 toggle() {
 this.isExpanded = !this.isExpanded;

 if (this.isExpanded) {
 // Mostrar ícones + títulos
                this.navContainer.classList.remove('collapsed');
                this.toggleButton.setAttribute('aria-expanded', 'true');
                this.toggleButton.setAttribute('aria-label', 'Recolher menu de navegação');
 } else {
 // Mostrar apenas ícones
                this.navContainer.classList.add('collapsed');
                this.toggleButton.setAttribute('aria-expanded', 'false');
                this.toggleButton.setAttribute('aria-label', 'Expandir menu de navegação');
 }

            console.log(`[MenuToggleManager] Menu ${this.isExpanded ? 'expandido' : 'recolhido'}`);
 }
 };

    document.addEventListener('DOMContentLoaded', () => MenuToggleManager.init());
 window.MenuToggleManager = MenuToggleManager;

})(window);
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-Navigation.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 NAVIGATION MANAGER
 Gerencia a navegação principal e seções (SPA).
 DRAWERS: Gerenciados pelo JS-DrawerManager.html
 ============================================================================ */

// ❌ DrawerManager REMOVIDO - Agora está no JS-DrawerManager.html
// O DrawerManager antigo estava em conflito com o novo

(function(window) {
    'use strict';

 const SectionManager = {
 init() {
            this.navContainer = document.getElementById('horizontal-nav');
 if (!this.navContainer) {
                console.error('[SectionManager] Container de navegação não encontrado.');
 return;
 }

            this.navContainer.addEventListener('click', (e) => {
                const navBtn = e.target.closest('.nav-btn');
 if (navBtn) {
 e.preventDefault();
 const sectionId = navBtn.dataset.section;
 if (sectionId) {
 this.switchSection(sectionId);
 }
 }
 });

            console.log('[SectionManager] ✅ Gerenciador de seções inicializado.');
 },

 switchSection(sectionId) {
 const targetSection = document.getElementById(`${sectionId}-section`);
 if (!targetSection) {
                console.warn(`[SectionManager] Seção '${sectionId}-section' não encontrada.`);
 return;
 }

 // 1. Esconde todas as seções
            const allSections = document.querySelectorAll('.app-main .section');
 allSections.forEach(section => {
                section.classList.add('hidden');
                section.classList.remove('active');
 });

 // 2. Mostra a seção alvo
            targetSection.classList.remove('hidden');
            targetSection.classList.add('active');

            // 3. Atualiza o estado 'active' nos botões de navegação
            const allNavBtns = this.navContainer.querySelectorAll('.nav-btn');
 allNavBtns.forEach(btn => {
                btn.classList.remove('active');
                btn.removeAttribute('aria-current');
 });

            const activeNavBtn = this.navContainer.querySelector(`.nav-btn[data-section="${sectionId}"]`);
 if (activeNavBtn) {
                activeNavBtn.classList.add('active');
                activeNavBtn.setAttribute('aria-current', 'page');
 }

 console.log(`[SectionManager] Seção trocada para: ${sectionId}`);

 // Dispara evento para outros módulos (ex: TabManager, CRUDManager)
            const sectionEvent = new CustomEvent('sectionChanged', { detail: { section: sectionId } });
 document.dispatchEvent(sectionEvent);
 }
 };

    document.addEventListener('DOMContentLoaded', () => SectionManager.init());
 window.SectionManager = SectionManager;

 // Exporta switchSection como função global para compatibilidade com onclick inline (temporário)
 window.switchSection = (sectionId) => SectionManager.switchSection(sectionId);

})(window);
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-SheetMapping.html -->
<!--============================================================================-->

<script>
/**
 * ============================================================================
 * SHEET MAPPING MANAGER - Frontend Module
 * ============================================================================
 *
 * Integração com SheetToSectionMapping.gs para resolução de nomenclaturas
 * Versão: 3.0 - Data-Driven Architecture
 * Data: 2025-10-16
 * ============================================================================
 */

(function(window) {
  'use strict';

 /**
 * Manages the mapping between frontend section IDs and backend Google Sheet names.
 * Uses a local cache to improve performance and an explicit API call for robustness.
 */
 const SheetMappingManager = {

 // Cache local do mapeamento
 _mappingCache: null,
 _cacheExpiry: null,
 _cacheDuration: 5 * 60 * 1000, // 5 minutos

 /**
 * Inicializa o gerenciador e carrega o mapeamento
 */
 async init() {
 try {
        Logger.info('[SheetMapping] Initializing...');
 await this.loadMapping();
        Logger.info('[SheetMapping] ✅ Mapping loaded successfully.');
 return { success: true };
 } catch (error) {
        Logger.error('[SheetMapping] ❌ Critical error loading mapping:', error);
 // Use o ToastManager global se disponível
 if (window.ToastManager) {
          ToastManager.show('Falha crítica ao carregar o mapeamento do sistema.', 'error', 10000);
 }
 return { success: false, error: error.message };
 }
 },

 /**
 * Loads mapping from the backend, using cache if available and valid.
 */
 async loadMapping() {
 if (this._mappingCache && this._cacheExpiry && Date.now() < this._cacheExpiry) {
        Logger.debug('[SheetMapping] Using cached mapping.');
 return this._mappingCache;
 }

      Logger.info('[SheetMapping] Fetching new mapping from backend...');
 try {
        const response = await API.run('getMappingData');

 if (response && response.success && response.data && response.data.sections) {
            this._mappingCache = response.data; // Armazena apenas o objeto 'data'
 this._cacheExpiry = Date.now() + this._cacheDuration;
 Logger.info(`[SheetMapping] ✅ Mapping carregado: ${this._mappingCache.totalSections || 0} seções, ${this._mappingCache.totalSheets || 0} planilhas`);
 return this._mappingCache;
 } else {
            Logger.error('[SheetMapping] ❌ Resposta inválida ou falha ao buscar mapeamento do backend:', response.error || 'Estrutura de resposta inesperada.');
            throw new Error('Falha ao carregar mapeamento do backend.');
 }
 } catch (error) {
        Logger.error('[SheetMapping] ❌ Erro crítico ao carregar mapeamento:', error);
 // Em caso de falha, não usamos mais um fallback complexo, apenas logamos o erro.
 // A aplicação deve lidar com a ausência do mapeamento.
 this._mappingCache = { sections: [], tables: {}, isFallback: true };
 throw error; // Propaga o erro para que o init() possa capturá-lo.
 }
 },

 /**
 * Gets the main backend sheet name for a given section.
     * @param {string} sectionId - ID da seção (ex: 'frequencia', 'compliance-validation')
 * @returns {string|null} Nome da planilha no backend
 */
 getSectionMainSheet(sectionId) {
 if (!this._mappingCache || !this._mappingCache.sections || this._mappingCache.sections.length === 0) {
        Logger.warn('[SheetMapping] Cache não inicializado. Execute init() primeiro.');
 return null; // Não usar fallback, falhar explicitamente.
 }

 const section = this._mappingCache.sections.find(s => s.id === sectionId);

 if (!section) {
        Logger.warn(`[SheetMapping] ⚠️ Seção '${sectionId}' não encontrada no mapeamento.`);
 return null;
 }

 return section.sheetName;
 },

 /**
 * Gets all associated sheet names for a section.
 * @param {string} sectionId - ID da seção
 * @returns {Array<string>} Lista de nomes de planilhas
 */
 getSectionSheets(sectionId) {
 if (!this._mappingCache || !this._mappingCache.sections || this._mappingCache.sections.length === 0) {
 return [];
 }

 const section = this._mappingCache.sections.find(s => s.id === sectionId);
 return section ? [section.sheetName] : []; // Simplificado para uma planilha por seção por enquanto
 },

 /**
 * Gets complete metadata for a section.
 * @param {string} sectionId - ID da seção
 * @returns {Object|null} Metadados da seção
 */
 getSectionMetadata(sectionId) {
 if (!this._mappingCache || !this._mappingCache.sections || this._mappingCache.sections.length === 0) {
 return null;
 }

 return this._mappingCache.sections.find(s => s.id === sectionId) || null;
 },

 /**
 * Gets table configuration for a specific sheet
 * @param {string} sheetName - Nome da planilha
 * @returns {Object|null} Configuração da tabela (colunas e campos)
 */
 getTableConfig(sheetName) {
 if (!this._mappingCache || !this._mappingCache.tables) {
        Logger.warn('[SheetMapping] Cache não contém configurações de tabelas');
 return null;
 }

 return this._mappingCache.tables[sheetName] || null;
 },

 /**
 * Gets table configuration for a section by first resolving the main sheet
 * @param {string} sectionId - ID da seção
 * @returns {Object|null} Configuração da tabela
 */
 getTableConfigForSection(sectionId) {
 const sheetName = this.getSectionMainSheet(sectionId);
 if (!sheetName) {
        Logger.warn(`[SheetMapping] Não foi possível resolver planilha para seção '${sectionId}'`);
 return null;
 }

 return this.getTableConfig(sheetName);
 },

 /**
 * Checks if a section is associated with multiple sheets.
 * @param {string} sectionId - ID da seção
 * @returns {boolean}
 */
 hasMultipleSheets(sectionId) {
 const sheets = this.getSectionSheets(sectionId);
 return sheets.length > 1;
 },

 /**
 * Gets the tab configuration for a section, if any.
 * @param {string} sectionId - ID da seção
 * @returns {Array<Object>|null} Array de tabs ou null
 */
 getSectionTabs(sectionId) {
 const metadata = this.getSectionMetadata(sectionId);
 return metadata && metadata.tabs ? metadata.tabs : null;
 },

 /**
 * Lists all available sections from the mapping.
 * @returns {Array<Object>} Array com todas as seções
 */
 getAllSections() {
 if (!this._mappingCache || !this._mappingCache.sections) {
        Logger.warn('[SheetMapping] Cache não inicializado');
 return [];
 }

 return this._mappingCache.sections;
 },

 /**
 * Validates if the mapping is correct against the backend.
 * @returns {Promise<Object>} Resultado da validação
 */
 async validateMapping() {
      const validationResult = await API.run('validateSheetMapping');
 if (validationResult && validationResult.success) {
        Logger.groupCollapsed('[SheetMapping] ✅ Resultado da Validação do Mapeamento');

 if (validationResult.unmappedSheets && validationResult.unmappedSheets.length > 0) {
            Logger.warn('⚠️ Planilhas não mapeadas (existem no backend, mas não no frontend):', validationResult.unmappedSheets);
 } else {
            Logger.info('👍 Todas as planilhas do backend estão mapeadas.');
 }

 if (validationResult.unmappedSections && validationResult.unmappedSections.length > 0) {
            Logger.warn('⚠️ Seções do frontend não encontradas no mapeamento do backend:', validationResult.unmappedSections);
 } else {
            Logger.info('👍 Todas as seções do frontend estão mapeadas.');
 }

 Logger.groupEnd();
 } else {
        Logger.error('[SheetMapping] ❌ Falha ao executar a validação do mapeamento:', validationResult?.error || 'Erro desconhecido.');
 }
 return validationResult;
 },

 /**
 * Clears the mapping cache.
 */
 clearCache() {
 this._mappingCache = null;
 this._cacheExpiry = null;
      Logger.debug('[SheetMapping] Cache limpo');
 },

 /**
 * Forces a reload of the mapping from the backend.
 */
 async reload() {
 this.clearCache();
 return await this.loadMapping();
 }
 };

 // Encapsulate into the main app object if it exists
 if (window.SIGTE_APP) {
 window.SIGTE_APP.SheetMappingManager = SheetMappingManager;
 } else {
 // Fallback to global scope if main app object is not ready
 window.SheetMappingManager = SheetMappingManager;
 }

  Logger.info('[SheetMapping] Module loaded. Use SheetMappingManager.init() to initialize.');

})(window);
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-TabManager.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 TAB MANAGER - Sistema de Abas para Seções Agrupadas
 ============================================================================
 Versão: 2.0 (Refatorado por Gemini Code Assist)
 Gerencia múltiplas planilhas dentro de uma mesma seção
 ============================================================================ */

(function() {
    'use strict';

 /**
 * Gerenciador de Tabs Reutilizável
 */
 const TabManager = {
 instances: {},

 /**
 * Cria um sistema de tabs para uma seção
 * @param {string} sectionId - ID da seção
 * @param {Array} tabs - Array de objetos {id, label, sheet, icon}
 * @param {Function} onTabChange - Callback quando tab é alterada
 */
 create(sectionId, tabs, onTabChange = () => {}) {
 if (!tabs || tabs.length <= 1) return null;

 const container = document.querySelector(`#${sectionId}-section`);
 if (!container) {
 console.warn(`[TabManager] Seção não encontrada: ${sectionId}`);
 return null;
 }

 // Se já existe uma instância, destrói antes de recriar
 if (this.instances[sectionId]) {
 this.destroy(sectionId);
 }

 // Cria navegação de tabs
            const tabNav = document.createElement('div');
            tabNav.className = 'tab-navigation';
            tabNav.setAttribute('role', 'tablist');

 const tabButtons = tabs.map((tab, index) => `
 <button
                    class="tab-button ${index === 0 ? 'active' : ''}"
                    data-tab-id="${tab.id}"
                    data-sheet-name="${tab.sheet}"
                    role="tab"
                    aria-selected="${index === 0}"
                    aria-controls="tab-panel-${tab.id}"
                    id="tab-${tab.id}">
                    ${tab.icon ? `<i class="fas fa-${tab.icon}"></i>` : ''}
 <span>${tab.label}</span>
 </button>
            `).join('');

 tabNav.innerHTML = `
                <div class="tab-navigation-inner">
 ${tabButtons}
 </div>
 `;

 // Insere no topo da seção, antes do conteúdo
            const pageHeader = container.querySelector('.page-header');
 if (pageHeader) {
                pageHeader.insertAdjacentElement('afterend', tabNav);
 } else {
 container.insertBefore(tabNav, container.firstChild);
 }

 // Cria painéis de conteúdo
            let tabPanelsContainer = container.querySelector('.tab-panels');
 if (!tabPanelsContainer) {
                tabPanelsContainer = document.createElement('div');
                tabPanelsContainer.className = 'tab-panels';

 // Adiciona o container de painéis após a navegação de abas
                tabNav.insertAdjacentElement('afterend', tabPanelsContainer);
 }

 tabs.forEach((tab, index) => {
 let panel = tabPanelsContainer.querySelector(`#tab-panel-${tab.id}`);
 // Cria o painel apenas se ele não existir
 if (!panel) {
                    panel = document.createElement('div');
 panel.id = `tab-panel-${tab.id}`;
                    panel.className = `tab-panel ${index === 0 ? 'active' : ''}`;
                    panel.setAttribute('role', 'tabpanel');
                    panel.setAttribute('aria-labelledby', `tab-${tab.id}`);
                    panel.innerHTML = `<div class="tab-crud-container" id="${sectionId}-${tab.id}-container"></div>`;
 tabPanelsContainer.appendChild(panel);
 }
 });

 // Event listener com delegação
 const tabClickHandler = (e) => {
                const button = e.target.closest('.tab-button');
 if (!button) return;

                const tabId = button.getAttribute('data-tab-id');
                const sheetName = button.getAttribute('data-sheet-name');

 this.switchTab(sectionId, tabId);
 onTabChange(tabId, sheetName);
 };

 // Adiciona event listener na navegação
            tabNav.addEventListener('click', tabClickHandler);

 // Salva instância
 this.instances[sectionId] = {
 tabs,
 currentTab: tabs[0].id,
 currentSheet: tabs[0].sheet,
 onTabChange,
 container,
 eventHandler: tabClickHandler
 };

 console.log(`[TabManager] Tabs criadas para ${sectionId}:`, tabs.length);

 return this.instances[sectionId];
 },

 /**
 * Troca de tab
 */
 switchTab(sectionId, tabId) {
 const instance = this.instances[sectionId];
 if (!instance) return;

 const container = document.querySelector(`#${sectionId}-section`);
 if (!container) return;

 // Atualiza botões
            container.querySelectorAll('.tab-button').forEach(btn => {
                const isActive = btn.getAttribute('data-tab-id') === tabId;
                btn.classList.toggle('active', isActive);
                btn.setAttribute('aria-selected', isActive);
 });

 // Atualiza painéis
            container.querySelectorAll('.tab-panel').forEach(panel => {
 const isActive = panel.id === `tab-panel-${tabId}`;
                panel.classList.toggle('active', isActive); // CSS fará a animação
 });

 // Atualiza estado
 const newTab = instance.tabs.find(t => t.id === tabId);
 if (!newTab) return;

 const sheetName = newTab.sheet;
 instance.currentTab = tabId;
 instance.currentSheet = sheetName;

 // Salva preferência
 try {
 localStorage.setItem(`sigte:tab:${sectionId}`, tabId);
 } catch (e) {
                console.warn('[TabManager] Erro ao salvar tab:', e);
 }

 console.log(`[TabManager] Tab ativada: ${sectionId} → ${tabId} (${sheetName})`);
 },

 /**
 * Obtém tab ativa
 */
 getCurrentTab(sectionId) {
 return this.instances[sectionId]?.currentTab || null;
 },

 /**
 * Obtém sheet ativa
 */
 getCurrentSheet(sectionId) {
 return this.instances[sectionId]?.currentSheet || null;
 },

 /**
 * Restaura última tab visitada
 */
 restoreLastTab(sectionId) {
 try {
 const lastTab = localStorage.getItem(`sigte:tab:${sectionId}`);
 if (lastTab) {
 const instance = this.instances[sectionId];
 const tab = instance?.tabs.find(t => t.id === lastTab);
 if (tab) {
 this.switchTab(sectionId, tab.id, tab.sheet);
 }
 }
 } catch (e) {
                console.warn('[TabManager] Erro ao restaurar tab:', e);
 }
 },

 /**
 * Destrói instância de tabs
 */
 destroy(sectionId) {
 const instance = this.instances[sectionId];
 if (!instance) return;

 const container = document.querySelector(`#${sectionId}-section`);
 if (container) {
 // Remove navegação de tabs
                const tabNav = container.querySelector('.tab-navigation');
 if (tabNav) tabNav.remove();

 // Remove painéis
                const tabPanels = container.querySelector('.tab-panels');
 if (tabPanels) tabPanels.remove();
 }

 delete this.instances[sectionId];
 console.log(`[TabManager] Instância destruída: ${sectionId}`);
 }
 };

 /**
 * Auto-inicialização de tabs quando seção é ativada
 */
    document.addEventListener('sectionChanged', async (e) => {
 const { section: sectionId, previousSection } = e.detail;

 // Limpa a instância de tabs da seção anterior
 if (previousSection && TabManager.instances[previousSection]) {
 TabManager.destroy(previousSection);
 }

 if (!window.SheetMappingManager || !window.CRUDManagerUniversal) {
            console.warn('[TabManager] SheetMappingManager não disponível');
 return;
 }

 const metadata = SheetMappingManager.getSectionMetadata(sectionId);
 if (!metadata || !metadata.tabs || metadata.tabs.length <= 1) {
 return; // Seção simples, sem tabs
 }

 if (!TabManager.instances[sectionId]) {
 console.log(`[TabManager] Criando tabs para: ${sectionId}`);

 TabManager.create(sectionId, metadata.tabs, (tabId, sheetName) => {
 console.log(`[TabManager] Tab alterada: ${tabId} → ${sheetName}`);

 const config = window.SECTION_CONFIGS?.[sectionId]; // Pega a config base da seção
 if (config) {
 // Cria uma instância de CRUD específica para esta tab
 CRUDManagerUniversal.init({
 ...config,
 sectionId: tabId, // Usa o ID da tab como identificador único
 containerId: `tab-panel-${tabId}`, // Renderiza dentro do painel da tab
 sheetName: sheetName,
 });
 }
 });

 TabManager.restoreLastTab(sectionId);
 }
 });

 window.TabManager = TabManager;
    console.log('[TabManager] Sistema de tabs carregado');
})();
</script>

<!--============================================================================-->
<!-- ARQUIVO: JS-UserDrawer.html -->
<!--============================================================================-->

<script>
/* ============================================================================
 USER DRAWER - Controla exibição de Login/Profile no drawer do usuário
 ============================================================================ */
(function() {
    'use strict';

 const UserDrawer = {
 init() {
            console.log('[UserDrawer] Inicializando...');
 this.updateDrawerView();

 // Atualizar quando usuário logar/sair
            document.addEventListener('auth-changed', () => {
 this.updateDrawerView();
 });
 },

 /**
 * Atualiza a view do drawer baseado no estado de autenticação
 */
 updateDrawerView() {
            const loginView = document.getElementById('login-view');
            const profileView = document.getElementById('profile-view');
            const logoutBtn = document.getElementById('logout-btn');

 if (!loginView || !profileView) return;

 if (AuthManager && AuthManager.isLoggedIn()) {
 // Usuário logado - mostrar perfil
                loginView.style.display = 'none';
                profileView.style.display = 'block';
                if (logoutBtn) logoutBtn.style.display = 'block';

 this.updateProfileInfo();
 } else {
 // Usuário não logado - mostrar login
                loginView.style.display = 'block';
                profileView.style.display = 'none';
                if (logoutBtn) logoutBtn.style.display = 'none';
 }
 },

 /**
 * Atualiza informações do perfil
 */
 updateProfileInfo() {
 const user = AuthManager.getCurrentUser();
 if (!user) return;

 // Avatar inicial
            const avatarInitial = document.getElementById('user-avatar-initial');
 if (avatarInitial) {
 avatarInitial.textContent = user.nome.charAt(0).toUpperCase();
 }

 // Nome
            const userName = document.getElementById('user-name-display');
 if (userName) {
 userName.textContent = user.nome;
 }

 // Role/Perfil
            const userRole = document.getElementById('user-role-display');
 if (userRole) {
 const roleLabels = {
                    'MONITOR': '👨‍✈️ Monitor',
                    'SECRETARIO': '👨‍💼 Secretário(a)',
                    'ADMIN': '👨‍💻 Administrador'
 };
 userRole.textContent = roleLabels[user.role] || user.role;
 }
 }
 };

 // Expor globalmente
 window.UserDrawer = UserDrawer;

 // Inicializar quando DOM e AuthManager estiverem prontos
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
 // Aguardar AuthManager estar disponível
 setTimeout(() => UserDrawer.init(), 100);
 });
 } else {
 setTimeout(() => UserDrawer.init(), 100);
 }

    console.log('[UserDrawer] Script carregado');

})();
</script>
