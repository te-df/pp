<!--============================================================================-->

<script>

/* * ============================================================================
 * SHEET MAPPING MANAGER - Frontend Module
 * ============================================================================
 *
 * Integra√ß√£o com SheetToSectionMapping.gs para resolu√ß√£o de nomenclaturas
 * Vers√£o: 3.0 - Data-Driven Architecture
 * Data: 2025-10-16
 * ============================================================================ */

(function(window) {
  'use strict';

 /* * Manages the mapping between frontend section IDs and backend Google Sheet names.
 * Uses a local cache to improve performance and an explicit API call for robustness. */
 const SheetMappingManager = {

 // Cache local do mapeamento
 _mappingCache: null,
 _cacheExpiry: null,
 _cacheDuration: 5 * 60 * 1000, // 5 minutos

 /* * Inicializa o gerenciador e carrega o mapeamento */
 async init() {
 try {
        Logger.info('[SheetMapping] Initializing...');
 await this.loadMapping();
        Logger.info('[SheetMapping] ‚úÖ Mapping loaded successfully.');
 return { success: true };
 } catch (error) {
        Logger.error('[SheetMapping] ‚ùå Critical error loading mapping:', error);
 // Use o ToastManager global se dispon√≠vel
 if (window.ToastManager) {
          ToastManager.show('Falha cr√≠tica ao carregar o mapeamento do sistema.', 'error', 10000);
 }
 return { success: false, error: error.message };
 }
 },

 /* * Loads mapping from the backend, using cache if available and valid. */
 async loadMapping() {
 if (this._mappingCache && this._cacheExpiry && Date.now() < this._cacheExpiry) {
        Logger.debug('[SheetMapping] Using cached mapping.');
 return this._mappingCache;
 }

      Logger.info('[SheetMapping] Fetching new mapping from backend...');
 try {
        const response = await API.run('getMappingData');

 if (response && response.success && response.data && response.data.sections) {
            this._mappingCache = response.data; // Armazena apenas o objeto 'data'
 this._cacheExpiry = Date.now() + this._cacheDuration;
 Logger.info(`[SheetMapping] ‚úÖ Mapping carregado: ${this._mappingCache.totalSections || 0} se√ß√µes, ${this._mappingCache.totalSheets || 0} planilhas`);
 return this._mappingCache;
 } else {
            Logger.error('[SheetMapping] ‚ùå Resposta inv√°lida ou falha ao buscar mapeamento do backend:', response.error || 'Estrutura de resposta inesperada.');
            throw new Error('Falha ao carregar mapeamento do backend.');
 }
 } catch (error) {
        Logger.error('[SheetMapping] ‚ùå Erro cr√≠tico ao carregar mapeamento:', error);
 // Em caso de falha, n√£o usamos mais um fallback complexo, apenas logamos o erro.
 // A aplica√ß√£o deve lidar com a aus√™ncia do mapeamento.
 this._mappingCache = { sections: [], tables: {}, isFallback: true };
 throw error; // Propaga o erro para que o init() possa captur√°-lo.
 }
 },

 /* * Gets the main backend sheet name for a given section.
     * @param {string} sectionId - ID da se√ß√£o (ex: 'frequencia', 'compliance-validation')
 * @returns {string|null} Nome da planilha no backend */
 getSectionMainSheet(sectionId) {
 if (!this._mappingCache || !this._mappingCache.sections || this._mappingCache.sections.length === 0) {
        Logger.warn('[SheetMapping] Cache n√£o inicializado. Execute init() primeiro.');
 return null; // N√£o usar fallback, falhar explicitamente.
 }

 const section = this._mappingCache.sections.find(s => s.id === sectionId);

 if (!section) {
        Logger.warn(`[SheetMapping] ‚ö†Ô∏è Se√ß√£o '${sectionId}' n√£o encontrada no mapeamento.`);
 return null;
 }

 return section.sheetName;
 },

 /* * Gets all associated sheet names for a section.
 * @param {string} sectionId - ID da se√ß√£o
 * @returns {Array<string>} Lista de nomes de planilhas */
 getSectionSheets(sectionId) {
 if (!this._mappingCache || !this._mappingCache.sections || this._mappingCache.sections.length === 0) {
 return [];
 }

 const section = this._mappingCache.sections.find(s => s.id === sectionId);
 return section ? [section.sheetName] : []; // Simplificado para uma planilha por se√ß√£o por enquanto
 },

 /* * Gets complete metadata for a section.
 * @param {string} sectionId - ID da se√ß√£o
 * @returns {Object|null} Metadados da se√ß√£o */
 getSectionMetadata(sectionId) {
 if (!this._mappingCache || !this._mappingCache.sections || this._mappingCache.sections.length === 0) {
 return null;
 }

 return this._mappingCache.sections.find(s => s.id === sectionId) || null;
 },

 /* * Gets table configuration for a specific sheet
 * @param {string} sheetName - Nome da planilha
 * @returns {Object|null} Configura√ß√£o da tabela (colunas e campos) */
 getTableConfig(sheetName) {
 if (!this._mappingCache || !this._mappingCache.tables) {
        Logger.warn('[SheetMapping] Cache n√£o cont√©m configura√ß√µes de tabelas');
 return null;
 }

 return this._mappingCache.tables[sheetName] || null;
 },

 /* * Gets table configuration for a section by first resolving the main sheet
 * @param {string} sectionId - ID da se√ß√£o
 * @returns {Object|null} Configura√ß√£o da tabela */
 getTableConfigForSection(sectionId) {
 const sheetName = this.getSectionMainSheet(sectionId);
 if (!sheetName) {
        Logger.warn(`[SheetMapping] N√£o foi poss√≠vel resolver planilha para se√ß√£o '${sectionId}'`);
 return null;
 }

 return this.getTableConfig(sheetName);
 },

 /* * Checks if a section is associated with multiple sheets.
 * @param {string} sectionId - ID da se√ß√£o
 * @returns {boolean} */
 hasMultipleSheets(sectionId) {
 const sheets = this.getSectionSheets(sectionId);
 return sheets.length > 1;
 },

 /* * Gets the tab configuration for a section, if any.
 * @param {string} sectionId - ID da se√ß√£o
 * @returns {Array<Object>|null} Array de tabs ou null */
 getSectionTabs(sectionId) {
 const metadata = this.getSectionMetadata(sectionId);
 return metadata && metadata.tabs ? metadata.tabs : null;
 },

 /* * Lists all available sections from the mapping.
 * @returns {Array<Object>} Array com todas as se√ß√µes */
 getAllSections() {
 if (!this._mappingCache || !this._mappingCache.sections) {
        Logger.warn('[SheetMapping] Cache n√£o inicializado');
 return [];
 }

 return this._mappingCache.sections;
 },

 /* * Validates if the mapping is correct against the backend.
 * @returns {Promise<Object>} Resultado da valida√ß√£o */
 async validateMapping() {
      const validationResult = await API.run('validateSheetMapping');
 if (validationResult && validationResult.success) {
        Logger.groupCollapsed('[SheetMapping] ‚úÖ Resultado da Valida√ß√£o do Mapeamento');

 if (validationResult.unmappedSheets && validationResult.unmappedSheets.length > 0) {
            Logger.warn('‚ö†Ô∏è Planilhas n√£o mapeadas (existem no backend, mas n√£o no frontend):', validationResult.unmappedSheets);
 } else {
            Logger.info('üëç Todas as planilhas do backend est√£o mapeadas.');
 }

 if (validationResult.unmappedSections && validationResult.unmappedSections.length > 0) {
            Logger.warn('‚ö†Ô∏è Se√ß√µes do frontend n√£o encontradas no mapeamento do backend:', validationResult.unmappedSections);
 } else {
            Logger.info('üëç Todas as se√ß√µes do frontend est√£o mapeadas.');
 }

 Logger.groupEnd();
 } else {
        Logger.error('[SheetMapping] ‚ùå Falha ao executar a valida√ß√£o do mapeamento:', validationResult?.error || 'Erro desconhecido.');
 }
 return validationResult;
 },

 /* * Clears the mapping cache. */
 clearCache() {
 this._mappingCache = null;
 this._cacheExpiry = null;
      Logger.debug('[SheetMapping] Cache limpo');
 },

 /* * Forces a reload of the mapping from the backend. */
 async reload() {
 this.clearCache();
 return await this.loadMapping();
 }
 };

 // Encapsulate into the main app object if it exists
 if (window.SIGTE_APP) {
 window.SIGTE_APP.SheetMappingManager = SheetMappingManager;
 } else {
 // Fallback to global scope if main app object is not ready
 window.SheetMappingManager = SheetMappingManager;
 }

  Logger.info('[SheetMapping] Module loaded. Use SheetMappingManager.init() to initialize.');

})(window);

</script>



<!--============================================================================-->